import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.Ai_99reE.js";const n="/vive-with-gemini/assets/Vue3%E2%86%92Nuxt%EF%BC%93%E7%A7%BB%E8%A1%8C%E6%88%A6%E7%95%A5%EF%BC%9AAI%E6%99%82%E4%BB%A3%E3%81%AE%E3%83%95%E3%83%AB%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E9%96%8B%E7%99%BA%E3%81%B8.m3_z8_OT.jpg",r="/vive-with-gemini/assets/%EF%BC%91.%E5%88%9D%E3%82%81%E3%81%AB%E2%80%95%E7%A7%BB%E8%A1%8C%E3%81%AE%E7%9C%9F%E3%81%AE%E7%9B%AE%E7%9A%84.4MQySeRE.jpg",l="/vive-with-gemini/assets/%EF%BC%92.%E3%81%AA%E3%81%9CNuxt3%E3%81%AA%E3%81%AE%E3%81%8B%EF%BC%9F%E9%96%8B%E7%99%BA%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E5%A4%89%E9%9D%A9.CrjQvsHi.jpg",o="/vive-with-gemini/assets/%EF%BC%93.%E5%AE%9F%E8%B7%B5%EF%BC%9AToppage%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E5%A4%89%E5%8C%96.Q8L_gNgl.jpg",p="/vive-with-gemini/assets/%EF%BC%93.%E5%AE%9F%E8%B7%B5%EF%BC%9ASupabase%E9%80%A3%E6%90%BA%E3%81%AE%E6%9C%80%E9%81%A9%E5%8C%96.DBTzXgU0.jpg",h="/vive-with-gemini/assets/%EF%BC%94.%E5%85%B7%E4%BD%93%E7%9A%84%E3%81%AA%E7%A7%BB%E8%A1%8C%E3%82%B9%E3%83%86%E3%83%83%E3%83%97.BDuMgudk.jpg",E="/vive-with-gemini/assets/%EF%BC%95.%E5%AD%A6%E3%81%B3%E3%81%A8%E6%B0%97%E3%81%A5%E3%81%8D%EF%BC%9A%E6%96%B0%E6%99%82%E4%BB%A3%E3%81%AE%E9%96%8B%E7%99%BA%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB.LIHyRXmF.jpg",g="/vive-with-gemini/assets/%EF%BC%96.%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%82%B7%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%EF%BC%9A%E3%82%88%E3%81%8F%E3%81%82%E3%82%8B%E8%90%BD%E3%81%A8%E3%81%97%E7%A9%B4.DJbPPLoR.jpg",d="/vive-with-gemini/assets/%EF%BC%97.%E5%BA%83%E7%BE%A9%E3%81%AE%E3%83%A2%E3%83%80%E3%83%B3%E5%8C%96%E6%88%A6%E7%95%A5%EF%BC%9ANuxt%E3%81%A8Next.js.DngZMP0h.jpg",c="/vive-with-gemini/assets/%EF%BC%97.%E7%A7%BB%E8%A1%8C%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%EF%BC%9A%E6%97%A2%E5%AD%98%E8%B3%87%E7%94%A3%E3%81%A8%E3%81%AE%E5%85%B1%E5%AD%98.B1SXahHq.jpg",k="/vive-with-gemini/assets/%EF%BC%98.%E7%B5%90%E8%AB%96%EF%BC%9AROI%E3%82%92%E6%9C%80%E5%A4%A7%E5%8C%96%E3%81%99%E3%82%8B%E3%83%AA%E3%83%97%E3%83%AC%E3%83%BC%E3%82%B9%E6%88%A6%E7%95%A5.DZ3eT72W.jpg",b=JSON.parse('{"title":"Vue3 → Nuxt3 マイグレーションガイド：Toppage 移行事例と次世代開発戦略","description":"","frontmatter":{},"headers":[],"relativePath":"appendix/migration-vue3-to-nuxt3.md","filePath":"appendix/migration-vue3-to-nuxt3.md"}'),u={name:"appendix/migration-vue3-to-nuxt3.md"};function A(B,s,F,m,x,C){return t(),a("div",null,[...s[0]||(s[0]=[e('<h1 id="vue3-→-nuxt3-マイグレーションガイド-toppage-移行事例と次世代開発戦略" tabindex="-1">Vue3 → Nuxt3 マイグレーションガイド：Toppage 移行事例と次世代開発戦略 <a class="header-anchor" href="#vue3-→-nuxt3-マイグレーションガイド-toppage-移行事例と次世代開発戦略" aria-label="Permalink to &quot;Vue3 → Nuxt3 マイグレーションガイド：Toppage 移行事例と次世代開発戦略&quot;">​</a></h1><p><img src="'+n+'" alt="Vue3→Nuxt３移行戦略：AI時代のフルスタック開発へ"></p><h2 id="_1-概要" tabindex="-1">1. 概要 <a class="header-anchor" href="#_1-概要" aria-label="Permalink to &quot;1. 概要&quot;">​</a></h2><p>本ドキュメントは、既存の Vue 3 スタンドアロンアプリケーション（Toppage プロジェクト）を、モダンなフルスタックフレームワークである <strong>Nuxt 3</strong> へマイグレーションする際の実践ガイドです。</p><p>単なる技術的な置き換えに留まらず、<strong>「AI × アジャイル」</strong> を最大化するための開発基盤の再構築を目的としています。</p><p><img src="'+r+'" alt="１.初めに―移行の真の目的：AI時代のフルスタック開発へ"></p><h2 id="_2-なぜ今、nuxt-3-フルスタック-なのか" tabindex="-1">2. なぜ今、Nuxt 3 (フルスタック) なのか？ <a class="header-anchor" href="#_2-なぜ今、nuxt-3-フルスタック-なのか" aria-label="Permalink to &quot;2. なぜ今、Nuxt 3 (フルスタック) なのか？&quot;">​</a></h2><h3 id="_2-1-分業から「1チーム・フルスタック」への変革" tabindex="-1">2.1 分業から「1チーム・フルスタック」への変革 <a class="header-anchor" href="#_2-1-分業から「1チーム・フルスタック」への変革" aria-label="Permalink to &quot;2.1 分業から「1チーム・フルスタック」への変革&quot;">​</a></h3><p>これまでの開発は「フロントエンド」と「バックエンド」を別チーム・別リポジトリで分業するのが一般的でした。しかし、Nuxt 3 のようなフルスタックフレームワークの導入により、この境界線が消失します。</p><ul><li><strong>AI × アジャイルの親和性</strong>: AI（Gemini等）を活用した開発では、フロントからDB連携までを一気通貫で指示・実装できる環境が理想的です。</li><li><strong>ROIの最大化</strong>: チーム内でフロント・バックの調整コストがゼロになり、ビジネス要求に対して臨機応変に、最短距離で価値を提供することが可能になります。</li><li><strong>結論</strong>: これからの主流は「分業」ではなく、<strong>1チーム内で全てが完結する AI 駆動型開発</strong> です。Nuxt 3 はそのための最強の「相棒」となります。</li></ul><h2 id="" tabindex="-1"><img src="'+l+'" alt="２.なぜNuxt3なのか？開発モデルの変革"> <a class="header-anchor" href="#" aria-label="Permalink to &quot;![２.なぜNuxt3なのか？開発モデルの変革](./../public/images/vue3-nuxt3/２.なぜNuxt3なのか？開発モデルの変革.jpg)&quot;">​</a></h2><h2 id="_3-toppage-プロジェクトにおける移行の実践" tabindex="-1">3. Toppage プロジェクトにおける移行の実践 <a class="header-anchor" href="#_3-toppage-プロジェクトにおける移行の実践" aria-label="Permalink to &quot;3. Toppage プロジェクトにおける移行の実践&quot;">​</a></h2><h3 id="_3-1-ディレクトリ構造の変化" tabindex="-1">3.1 ディレクトリ構造の変化 <a class="header-anchor" href="#_3-1-ディレクトリ構造の変化" aria-label="Permalink to &quot;3.1 ディレクトリ構造の変化&quot;">​</a></h3><p>既存の <code>src/</code> 構成から、Nuxt 3 標準のディレクトリ構造へ移行しました。</p><ul><li><strong><code>components/</code></strong>: 自動インポート機能により、面倒な <code>import</code> 文が不要になりました。</li><li><strong><code>server/api/</code></strong>: これまで外部（Vercel Functions 等）に切り出していた DB 操作ロジックをプロジェクト内に統合。</li><li><strong><code>nuxt.config.ts</code></strong>: 環境変数（Supabase 等）を安全かつ一元的に管理。</li></ul><p><img src="'+o+'" alt="３.実践：Toppageプロジェクトのアーキテクチャ変化"></p><h3 id="_3-2-supabase-連携の最適化" tabindex="-1">3.2 Supabase 連携の最適化 <a class="header-anchor" href="#_3-2-supabase-連携の最適化" aria-label="Permalink to &quot;3.2 Supabase 連携の最適化&quot;">​</a></h3><p>Nuxt モジュール（<code>@nuxtjs/supabase</code>）を活用し、フロント・バック両面での接続を安定化させました。</p><ul><li><strong>サーバーサイド</strong>: <code>serverSupabaseClient(event)</code> を使用し、API ルートでの DB 操作をセキュアに実装。</li><li><strong>フロントエンド</strong>: <code>useFetch</code> にユニークな <code>key</code> を指定することで、複数コンポーネント間でのキャッシュ競合を解決。</li></ul><p><img src="'+p+`" alt="３.実践：Supabase連携の最適化"></p><hr><h2 id="_4-具体的なマイグレーション・ステップ" tabindex="-1">4. 具体的なマイグレーション・ステップ <a class="header-anchor" href="#_4-具体的なマイグレーション・ステップ" aria-label="Permalink to &quot;4. 具体的なマイグレーション・ステップ&quot;">​</a></h2><h3 id="step-1-プロジェクトの初期化と環境構築" tabindex="-1">STEP 1：プロジェクトの初期化と環境構築 <a class="header-anchor" href="#step-1-プロジェクトの初期化と環境構築" aria-label="Permalink to &quot;STEP 1：プロジェクトの初期化と環境構築&quot;">​</a></h3><p>Windows 環境から Ubuntu (WSL) 等の Linux 環境へ移行する際は、OS 依存のバイナリ整合性に注意が必要です。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 既存の node_modules をリセット（OS依存エラーの回避）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -rf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package-lock.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span></span></code></pre></div><h3 id="step-2-api-ルートへのロジック移管" tabindex="-1">STEP 2：API ルートへのロジック移管 <a class="header-anchor" href="#step-2-api-ルートへのロジック移管" aria-label="Permalink to &quot;STEP 2：API ルートへのロジック移管&quot;">​</a></h3><p>フロントエンドに書いていた DB 操作を <code>server/api/*.ts</code> へ移します。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// server/api/get-count.ts の例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { serverSupabaseClient } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;#supabase/server&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineEventHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> supabase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> serverSupabaseClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> supabase.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;page_views&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="step-3-vercel-デプロイ設定の変更" tabindex="-1">STEP 3：Vercel デプロイ設定の変更 <a class="header-anchor" href="#step-3-vercel-デプロイ設定の変更" aria-label="Permalink to &quot;STEP 3：Vercel デプロイ設定の変更&quot;">​</a></h3><p>ここが移行成功の鍵となります。</p><ol><li><strong>Framework Preset</strong>: <code>Nuxt.js</code> を選択。</li><li><strong>Root Directory</strong>: <code>nuxt-app</code>（またはプロジェクトのディレクトリ名）を明示的に指定。</li><li><strong>Environment Variables</strong>: <code>SUPABASE_URL</code> / <code>SUPABASE_KEY</code> を Vercel 側に登録。</li></ol><p><img src="`+h+'" alt="４.具体的な移行ステップ"></p><hr><h2 id="_5-学びと気づき-2026年の開発スタイル" tabindex="-1">5. 学びと気づき：2026年の開発スタイル <a class="header-anchor" href="#_5-学びと気づき-2026年の開発スタイル" aria-label="Permalink to &quot;5. 学びと気づき：2026年の開発スタイル&quot;">​</a></h2><p>Toppage プロジェクトの移行を通じて、以下のことが明確になりました。</p><ol><li><strong>FW が煩わしさを吸収</strong>: ファイルベースルーティングや状態管理の自動化により、開発者は「機能（ロジック）」そのものに集中できるようになりました。</li><li><strong>「相棒」としてのAI活用</strong>: Nuxt 3 の一貫した構造は AI にとっても理解しやすく、ペアプログラミングの精度が飛躍的に向上しました。</li><li><strong>未来の選択肢</strong>: 新規プロジェクトはもちろん、既存資産のリプレースにおいても、バックエンドを Node.js (TypeScript) に集約し、フルスタック化することは、資産流用と開発速度の両面で「一択」の正解と言えます。</li></ol><p><img src="'+E+'" alt="５.学びと気づき：新時代の開発スタイル"></p><hr><h2 id="_6-付録-トラブルシューティング" tabindex="-1">6. 付録：トラブルシューティング <a class="header-anchor" href="#_6-付録-トラブルシューティング" aria-label="Permalink to &quot;6. 付録：トラブルシューティング&quot;">​</a></h2><ul><li><strong>「Error」表示が消えない</strong>: API が期待するパラメータ（<code>field=views</code> 等）とフロント側の <code>useFetch</code> が合致しているか確認してください。</li><li><strong>デプロイ後に画面が変わらない</strong>: Vercel の Root Directory 設定を再確認し、ビルドログで Nuxt が正しくビルドされているかチェックしてください。</li></ul><hr><p>ドキュメントの構成としては、現在の <code>migration-vue3-to-nuxt3.md</code> に**「第7章：広義のモダン化戦略」<strong>として統合するのがベストです。これにより、単なる「Toppageの移行手順書」ではなく、</strong>「技術選定とリプレースの指針」**としての価値が生まれます。</p><p>ご提示いただいた2つの視点を踏まえ、以下のように拡充内容を構成しました。</p><p><img src="'+g+'" alt="６.トラブルシューティング：よくある落とし穴"></p><h2 id="_7-広義のモダン化戦略とリプレースパターン" tabindex="-1">7. 広義のモダン化戦略とリプレースパターン <a class="header-anchor" href="#_7-広義のモダン化戦略とリプレースパターン" aria-label="Permalink to &quot;7. 広義のモダン化戦略とリプレースパターン&quot;">​</a></h2><h3 id="_7-1-nuxt-3-と-next-js-のパラレル関係" tabindex="-1">7.1 Nuxt 3 と Next.js のパラレル関係 <a class="header-anchor" href="#_7-1-nuxt-3-と-next-js-のパラレル関係" aria-label="Permalink to &quot;7.1 Nuxt 3 と Next.js のパラレル関係&quot;">​</a></h3><p>Vue 3 から Nuxt 3 への移行は、React エコシステムにおける <strong>React (Vite) から Next.js への移行</strong>と本質的に同義です。</p><ul><li><p><strong>共通の進化</strong>: どちらも「ライブラリ（表示）」から「フレームワーク（機能）」への進化であり、以下の共通メリットを享受できます。</p></li><li><p><strong>Zero Config</strong>: ルーティングやビルド設定の標準化。</p></li><li><p><strong>Server-Side Capability</strong>: エッジネットワーク（Vercel 等）での高度な実行環境。</p></li><li><p><strong>選択の指針</strong>: どちらも「1チームでの AI×アジャイル開発」を加速させるツールであり、既存資産やチームのスキルセット（Vue か React か）に応じて選択します。</p></li></ul><p><img src="'+d+'" alt="７.広義のモダン化戦略：NuxtとNext.js"></p><h3 id="_7-2-既存資産-c-sql-server-等-を活かした移行パターン" tabindex="-1">7.2 既存資産（C# / SQL Server 等）を活かした移行パターン <a class="header-anchor" href="#_7-2-既存資産-c-sql-server-等-を活かした移行パターン" aria-label="Permalink to &quot;7.2 既存資産（C# / SQL Server 等）を活かした移行パターン&quot;">​</a></h3><p>現行の基幹システム（販売管理等）のリプレースにおいて、全てのバックエンドを Node.js に置き換えるのが正解とは限りません。特に <strong>C# + SQL Server + Azure</strong> といった堅牢な資産がある場合は、以下の <strong>「ハイブリッド型」</strong> の移行が現実的かつ高効率です。</p><h4 id="移行パターン-api-gateway-としてのフルスタック活用" tabindex="-1"><strong>移行パターン：API Gateway としてのフルスタック活用</strong> <a class="header-anchor" href="#移行パターン-api-gateway-としてのフルスタック活用" aria-label="Permalink to &quot;**移行パターン：API Gateway としてのフルスタック活用**&quot;">​</a></h4><ol><li><strong>現行資産の API 化</strong>:</li></ol><ul><li>既存の C# ロジックを ASP.NET Core API 等でラップし、データアクセス層として存続させます。</li></ul><ol start="2"><li><strong>Nuxt / Next による「フロント＋中間層」の構築</strong>:</li></ol><ul><li><strong>BFF (Backend For Frontend)</strong> として Nuxt/Next を採用します。</li><li>ブラウザから直接 C# サーバーを叩くのではなく、Nuxt の <code>server/api</code> を経由させます。</li></ul><ol start="3"><li><strong>メリット</strong>:</li></ol><ul><li><strong>資産の有効活用</strong>: 複雑なビジネスロジックが詰まった C# 資産を再利用し、リスクを低減できます。</li><li><strong>UI の高速化</strong>: フロントエンド側は Nuxt の恩恵を受け、モダンで高速なユーザー体験を提供できます。</li><li><strong>AI 駆動開発の適用</strong>: 変更頻度の高い UI 周りは AI×アジャイルで Nuxt 側を高速に回し、データ層（C#）は堅牢に維持するという「速度の使い分け」が可能になります。</li></ul><div class="tip custom-block"><p class="custom-block-title">AIを活用した「完全移行」への布石</p><p>「既存の C# 資産を TypeScript (Node.js) へ完全に移行するのは、難易度が高い」と躊躇されがちですが、実は <strong>AI（Gemini 等）をペアワークに活用した移行方針が綿密に固まれば、その難易度は決して高くありません。</strong> C# の型定義やロジックは AI との親和性が非常に高く、適切なプロンプトと設計指針があれば、高精度かつ高速に TypeScript へ変換可能です。まずはハイブリッド型で始めつつ、AI を「翻訳者」として使い倒すことで、将来的な完全モダン化へのハードルを劇的に下げることができます。</p></div><p><img src="'+c+'" alt="７.移行パターン：既存資産との共存"></p><hr><h2 id="_8-結論-リプレースにおける-roi-の考え方" tabindex="-1">8. 結論：リプレースにおける ROI の考え方 <a class="header-anchor" href="#_8-結論-リプレースにおける-roi-の考え方" aria-label="Permalink to &quot;8. 結論：リプレースにおける ROI の考え方&quot;">​</a></h2><p>新規作成であれば <strong>「Nuxt / Next 一択」</strong> ですが、大規模な既存リプレースでは <strong>「バックエンド（C# 等）を資産流用として残し、フロントエンド層をフルスタックフレームワークでラップする」</strong> という選択肢が、コスト対効果（ROI）を最大化させる最短距離となります。</p><p><img src="'+k+'" alt="８.結論：ROIを最大化するリプレース戦略"></p><p>これにより、開発チームは「AI × アジャイル」による柔軟性を手に入れつつ、基幹システムの信頼性を担保し続けることができます。</p><hr>',66)])])}const v=i(u,[["render",A]]);export{b as __pageData,v as default};
