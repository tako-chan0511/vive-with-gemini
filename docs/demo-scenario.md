# 私たちの開発風景 (デモシナリオ)

## 仕様変更に追随する「進化するテスト」の実演

**[私のトーク（導入）]**
「本日は、私とAIの相棒であるGeminiが、日常的にどのように協力して開発を進めているか、その一端を『バイブコーディング』と名付けてお見せします。テーマは、アジャイル開発における永遠の課題、『テストコードの保守』です。テストは品質の砦ですが、仕様変更のたびに修正するのは大きなコストになります。このコストを、私たちがどうやってROIの高い活動に変えているか、ご覧ください。」

---

### ステップ1：テストが存在しない状態

**[アクション]**
1.  `companyAnalysis.ts` ファイルを開き、`getCompanyAttentionLevel` 関数を見せる。
2.  対応するテストファイルが空であることを見せる。

**[私のトーク]**
「ここに、企業の注目度を判定する簡単な関数があります。まずは、この関数に対するテストコードを、私の相棒にゼロから作成してもらいます。」

**`companyAnalysis.ts`**
```typescript
export function getCompanyAttentionLevel(newsCount: number): '高' | '中' | '低' {
  if (newsCount >= 20) {
    return '高';
  } else if (newsCount >= 5) {
    return '中';
  } else {
    return '低';
  }
}
```

---

### ステップ2：AIによるテストの初回作成

**[アクション]**
1.  Geminiのチャット画面を開き、関数のコードを貼り付け、プロンプトを入力する。

**[私のトーク]**
「では、彼にこう頼んでみましょう。『この関数の全ルートを網羅するテストを、Vitestで作って』と。ここでのポイントは、私が細かいテストケースを考えなくても良い、という点です。」

**[私からGeminiへのプロンプト]**
> この`getCompanyAttentionLevel`関数の単体テストを、C1網羅率100%になるようにVitestで作成してください。

**[アクション]**
1.  Geminiが生成したテストコードをコピーし、テストファイルに貼り付けて保存する。
2.  ターミナルで `npx vitest run --coverage` を実行し、カバレッジレポートを見せる。
    *[注：このコマンドは`package.json`のscripts設定に依存します]*

**[私のトーク]**
「はい、提案してくれました。これを貼り付けて、テストを実行します…。ご覧ください。ほんの数十秒の対話で、エッジケースまで考慮された網羅率100%のテストスイートが完成しました。通常なら数十分かかるこの作業コストが、ほぼゼロになった瞬間です。」

---

### ステップ3：仕様変更とテストの自動追随

**[アクション]**
1.  `companyAnalysis.ts` ファイルのロジックを直接編集する。

**[私のトーク]**
「ここで、ビジネスサイドから緊急の仕様変更依頼が来たと仮定します。『注目度: 高の基準を上げ、新たに"超高"ランクを追加する』という内容です。私がまず、仕様通りに関数のロジックだけを修正します。」

**`companyAnalysis.ts` (変更後)**
```typescript
export function getCompanyAttentionLevel(newsCount: number): '超高' | '高' | '中' | '低' {
  if (newsCount >= 50) { // "超高"ランクを追加
    return '超高';
  } else if (newsCount >= 30) { // 基準を20から30に変更
    return '高';
  } else if (newsCount >= 5) {
    return '中';
  } else {
    return '低';
  }
}
```

**[アクション]**
1.  古いテストコードのまま、再度テストを実行し、テストが**失敗**する様子を見せる。

**[私のトーク]**
「当然ですが、既存のテストは失敗します。しかし、これは良いサインです。私たちの『品質のセーフティーネット』が、仕様変更を正しく検知した証拠ですからね。ここからが私たちの本番です。この状況を、今度はそのまま相棒に伝えて、テストの修正を依頼します。」

**[アクション]**
1.  Geminiのチャット画面に、**変更後の関数コード**と**古いテストコード**を両方貼り付け、プロンプトを入力する。

**[私からGeminiへのプロンプト]**
> この関数の仕様が変わったんだ。この新しいロジックに合わせて、既存のテストコードを修正・更新してくれないかな？もちろん、網羅率100%はキープしてほしい。

**[アクション]**
1.  Geminiが生成した**更新版のテストコード**をテストファイルに貼り付け、上書き保存する。
2.  再度テストを実行し、全てのテストが通り、カバレッジも100%に復帰することを見せる。

**[私のトーク（まとめ）]**
「彼が更新してくれたコードを貼り付けます…。はい、ご覧ください。新しい仕様に完璧に追随したテストに修正され、再びオールグリーンになりました。仕様変更に伴うテスト修正という、開発で最もコストのかかる作業の一つが、創造的な対話に変わりました。このように、**変化への対応コストを劇的に下げ、常に品質を高く保つ**こと。これが、私たちの『バイブコーディング』がもたらす、最も大きな価値であり、ROI向上への直接的な貢献です。」