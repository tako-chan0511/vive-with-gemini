## １ IaCの進化：構成管理から不変インフラへ
![te1.IaCの進化：構成管理から不変インフラへ](/images/IaC/te1.IaCの進化：構成管理から不変インフラへ.jpg)

### 図の要旨
- IaC（Infrastructure as Code）は「サーバーに後から設定を流し込む時代」から、「クラウド資源を宣言して作り替える時代」へ進化した、という導入スライドです。
- 左の“物理サーバー”っぽい絵は **手作業で育てる運用**、中央のクラウドは **抽象化されたリソース**、右のコードは **宣言（desired state）** を表しています。

### 詳細解説（用語）
- **IaC**：インフラ構成（ネットワーク、サーバー、LB、DB、IAM等）をコードで表現し、再現可能にする考え方。
- **構成管理（Configuration Management）**：OS内の設定（パッケージ、サービス、ユーザー等）を揃える活動。
- **不変インフラ（Immutable Infrastructure）**：既存サーバーを“修理”せず、更新は“作り直し（置換）”で行う運用モデル。
- **Desired State（望ましい状態）**：現状を操作手順で書くのではなく、「最終的にこうあるべき」をコード化する思想。

### Tips（実務）
- 「IaCやりたい」の最初の一歩は、**“再現できること”を定義**することです。  
  例：`dev`環境を「誰が作っても同じVPC/サブネット/ALB/ASG」になる、など。
- 最初から全部IaC化しない：  
  **(1)ネットワーク → (2)コンピュート → (3)監視/ログ → (4)アプリ設定** の順に範囲を広げると事故が減ります。

---

## ２ インフラ進化の年表
![te2.インフラ進化の年表](/images/IaC/te2.インフラ進化の年表.jpg)

### 図の要旨
- 2006〜2014の節目を並べ、「課題の中心がサーバー設定からリソースのライフサイクルへ移った」ことを示しています。
- EC2で“作れる”ようになり、Chef/Ansibleで“揃えられる”ようになり、Docker/Kubernetesで“短命な単位で回せる”ようになり、Terraformで“全体を宣言して組み立てる”方向へ進んだ、という流れです。

### 詳細解説（用語）
- **Day 0 / Day 1 / Day 2**
  - Day 0：基盤準備（ネットワーク/アカウント/設計）
  - Day 1：初期構築（サーバー起動、LB/DB作成、デプロイ開始）
  - Day 2：運用（パッチ、ログ、スケール、障害対応、変更）
- **クラウドネイティブ**：インフラが“静的資産”ではなく、“APIで作って捨てる資源”として扱える前提。

### Tips（実務）
- この年表を現場で使うなら「自社の今はどこか」を決めるのが効果的です。  
  例：  
  - まだSSH運用中心 → p04〜p06が刺さる  
  - 既にKubernetes運用 → p14の“分担”が刺さる

---

## ３ 2010年代前半の課題：サーバー内部の「構成管理」
![te3.2010年代前半の課題：サーバー内部の「構成管理」](/images/IaC/te3.2010年代前半の課題：サーバー内部の「構成管理」.jpg)

### 図の要旨
- “空のサーバー50台にどうやって同じソフトを入れて、同じ状態にするか？”が当時の主戦場だった、という説明です。
- Chef/Puppet/Ansibleなどで **OS内部の設定を自動化**して、Day 2（運用）を回しやすくしたのが第1世代。

### 詳細解説（用語）
- **Control Node**：設定を流す側（管理サーバー/実行元）。
- **Managed Node**：設定される側（対象サーバー）。
- **Idempotency（冪等性）**：同じ処理を何度実行しても結果が変わらない性質（構成管理の命）。
- **Provisioning（プロビジョニング）**：サーバー/環境を用意して使える状態にすること（構成管理と混ざりやすいので要注意）。

### Tips（実務）
- 「構成管理が必要な場面」は今もあります。  
  例：VM（EC2）上でミドル（nginx、ログ収集、監視Agent）を揃える、など。
- ただし、クラウドでは“設定の前に” **ネットワーク/IAM/LB/DB** をAPIで作る必要があり、ここが次の世代の焦点になります（p09）。

---

## ４ 可変インフラ（Mutable）と「ペット」運用
![te4.可変インフラ（MutableInfrastruture）と「ペット」としてのアプローチ](/images/IaC/te4.可変インフラ（MutableInfrastruture）と「ペット」としてのアプローチ.jpg)

### 図の要旨
- サーバーを長生きさせ、問題が起きたらSSHで治療（修正）する運用＝Pets（ペット）という比喩です。
- 変更が“その場当て”になりやすく、時間が経つほど個体差が増える（＝後で効いてくる）点が弱みです。

### 詳細解説（用語）
- **Mutable Infrastructure**：既存の実体に対して“上書き変更”していく運用。
- **Snowflake Server**：二度と同じものを作れない“唯一無二”のサーバー（後述p06）。
- **手作業パッチ**：緊急対応では必要になるが、長期的には再現性を壊しやすい。

### Tips（実務）
- それでもSSHが必要になる局面はゼロになりません。  
  重要なのは「SSHで直したら、**必ずコードに戻す**」運用ルールです。  
  例：緊急で設定変更 → その差分をTerraform/Ansible/AMIビルドに反映 → 次回は置換で適用。
- “治療”を許すなら、必ず **「いつ・誰が・何を」** を残す仕組み（監査ログ/Runbook/チケット）がセット。

---

## ５ なぜAnsibleが第1世代の勝者となったのか
![te5.なぜAnsibleが第１世代の勝者となったのか](/images/IaC/te5.なぜAnsibleが第１世代の勝者となったのか.jpg)

### 図の要旨
- Chef/Puppetは **エージェント導入**やDSL（Ruby等）の学習が必要だったのに対し、
  Ansibleは **Agentless（SSHのみ）**＋読みやすいYAMLで導入障壁を下げた、という比較です。

### 詳細解説（用語）
- **Agent / Agentless**
  - Agent：対象サーバーに常駐プロセスを入れて管理する方式（機能は強いが運用が増える）
  - Agentless：SSH等で外から実行する方式（導入が軽い）
- **DSL**：特定用途向け言語。柔軟だが学習コストが上がりやすい。

### Tips（実務）
- “勝者”の理由は技術力より **運用コスト**です。  
  例：対象台数が増えるほど「Agentの更新・監視・障害対応」が地味に効きます。
- Ansibleは今でも「アプリ設定」「OS設定」「一時作業」に強い。  
  ただしクラウド資源の作成（VPC等）を主戦場にすると、Terraform領域と競合します（p12）。

---

## ６ 可変モデルの限界：構成ドリフトの発生
![te6.可変モデルの限界：構成ドリフトの発生](/images/IaC/te6.可変モデルの限界：構成ドリフトの発生.jpg)

### 図の要旨
- 同じ“V1.0”から始めたはずなのに、  
  手動Hotfix／自動更新／更新失敗…でバラバラになり、最後に“雪の結晶（Snowflakes）”が生まれる流れを示しています。
- その結果、「ステージングで動くのに本番で動かない」問題が起きやすくなります。

### 詳細解説（用語）
- **構成ドリフト（Configuration Drift）**：意図した構成（コード/手順）と、実際の状態が時間と共にズレること。
- **Hotfix**：緊急の局所修正。速いが、再現性の敵になりやすい。
- **ドリフトの“負債化”**：ズレが積み上がるほど、原因調査と復旧が難しくなる。

### Tips（実務）
- ドリフト対策は3段階で考えると現場で使えます。
  1. **検知**：Terraformなら `plan`、クラウドならConfig系サービス、OSなら監視/差分収集  
  2. **抑制**：本番への手作業禁止、権限分離、Change管理  
  3. **解消**：置換（Immutable）・再構築（Blue/Green、Rolling）へ寄せる
- 「手動はゼロにできない」前提で、**“手動が発生しても戻せる”** 設計が重要です（例：ASG＋起動テンプレートで置換できる構成）。

---

## ７ 手続き型から宣言型への転換
![te7.手続き型（Procedural）から宣言型（Declarative）への転換](/images/IaC/te7.手続き型（Procedural）から宣言型（Declarative）への転換.jpg)

### 図の要旨
- 手続き型（HOW）は「どうやって到達するか」を書く。開始条件がズレると結果もズレやすい。
- 宣言型（WHAT）は「どこに到達したいか」を書く。手段（順序/依存関係）はシステムが計算する。
- “インフラの状態そのものをドキュメント化する”というメッセージがコアです。

### 詳細解説（用語）
- **Procedural（手続き型）**：ステップを順に実行する発想（例：AしてBしてCして…）。
- **Declarative（宣言型）**：最終状態を宣言し、差分を収束させる発想。
- **Converge（収束）**：望ましい状態へ近づける（差分適用を繰り返して一致させる）考え方。

### Tips（実務）
- 宣言型が効くのは「依存関係が多い」領域です。  
  例：VPC→Subnet→Route→SG→EC2→LB→DNS のように、順序が意味を持つ構成。
- ただし宣言型でも「データ移行」「一時停止が必要な変更」など、手順の設計が要るものがあります。  
  → ここを“全部自動”と誤解しないのが安全です。

---

## ８ 第2世代の解答：不変インフラと「家畜」
![te8.第２世代の回答：不変インフラ（ImmutableInfrastructure）と「家畜」](/images/IaC/te8.第２世代の回答：不変インフラ（ImmutableInfrastructure）と「家畜」.jpg)

### 図の要旨
- サーバーは修理せず、更新時は捨てて新しく作る＝Cattle（家畜）という比喩。
- これにより「ゼロ・ドリフト」＝コードと実環境の一致を目指す。

### 詳細解説（用語）
- **Immutable Infrastructure**：作成後は“変更しない”前提。変更は新しい実体を作って切り替える。
- **Image（AMI等）**：不変運用の材料。OS＋ミドル＋設定の“焼き込み済み”テンプレ。
- **Replace（置換）**：旧を残したまま新を作り、切り替え後に旧を捨てる（安全にやりやすい）。

### Tips（実務）
- 不変化の実装パターン（現場で頻出）
  - **Auto Scaling Group + Launch Template**：テンプレ更新→ローリング置換  
  - **Blue/Green**：新環境を丸ごと作って切替（DNS/ALB/Routeでスイッチ）
  - **Immutable Container**：イメージタグ（digest）固定で再現性を担保
- 「置換できないもの（DBなど）」は、**不変化の対象外**として割り切り、  
  “スキーマ移行/バックアップ/切戻し”を別レイヤーで設計するのが現実解です。

---

## ９ Terraformの登場：クラウド・オーケストレーションの覇権
![te9.Terraformの登場：クラウド＆オーケストレーションの覇権](/images/IaC/te9.Terraformの登場：クラウド＆オーケストレーションの覇権.jpg)

### 図の要旨
- Ansibleが得意な「OS内の設定」ではなく、Terraformは「クラウド資源のライフサイクル（作成・変更・削除）」を主戦場にした、という位置づけです。
- AWS/Azure/Google Cloudのような複数クラウドを同じ思想で扱える点が大きい。

### 詳細解説（用語）
- **Orchestration（オーケストレーション）**：複数リソースを依存関係込みで統合的に作ること。
- **Lifecycle（ライフサイクル）**：create / update / delete を安全に回す考え方。
- **Provider**：クラウド/APIに接続するためのプラグイン（Terraformの拡張単位）。

### Tips（実務）
- 役割分担の原則：  
  - Terraform：**VPC/LB/DB/IAM/監視の骨格**（“家”を建てる）  
  - Ansible：**OS/ミドル/設定**（“家具を置く”）  
  これを守ると、責任境界が綺麗になります（p14）。
- “マルチクラウド”は目的が重要です。  
  例：DR、買収、顧客要件…がないのに無理にやると運用が重くなります。

---

## １０ Terraformの技術的優位性：HCLとState管理
![te10.Terraformの技術的優位性：HCLとState管理](/images/IaC/te10.Terraformの技術的優位性：HCLとState管理.jpg)

### 図の要旨
- HCLでDesired Stateを書き、Stateファイルで“現実”を追跡し、エンジンが依存関係グラフ（DAG）で順序を自動化する、という内部構造の説明です。

### 詳細解説（用語）
- **HCL**：Terraformの宣言言語。可読性重視で、変数/モジュールなどで再利用できる。
- **State file（tfstate）**：Terraformが管理する「理想（コード）と現実（リソースID等）」の対応表。
- **DAG（Dependency Graph）**：依存関係をグラフとして解き、正しい順序で作成/変更/削除する仕組み。

### Tips（実務）
- Stateは“心臓”なので運用設計が必須です。
  - **リモート保存**（例：S3等）＋**ロック**（例：DynamoDB等）で同時更新事故を防ぐ
  - **Stateを分割**（環境/レイヤー/システム単位）してblast radiusを小さくする
- DAGの恩恵は「人が順序を覚えなくてよい」こと。  
  ただし **暗黙依存**（参照を書かない）だと事故るので、参照関係は明示するのが鉄則。

---

## １１ 予測可能性：Terraform Plan vs Ansible Check
![te11.予測可能性の担保：TerraformPlan対AnsibleCheck](/images/IaC/te11.予測可能性の担保：TerraformPlan対AnsibleCheck.jpg)

### 図の要旨
- Terraform Planは「何が変わるか」を事前に確定的に示しやすい（決定的）。
- Ansible Checkは実機状態に依存し、結果がブレる可能性がある、という比較です。
- “Planは変更の契約書”という言い切りがポイント。

### 詳細解説（用語）
- **Plan**：apply前に差分を算出して見せるステップ。
- **Deterministic（決定的）**：同じ入力なら同じ結果になりやすい性質。
- **Drift-aware**：State/実環境のズレを検知して差分に反映できる性質。

### Tips（実務）
- 本番運用では、最低限この流れを守ると事故が減ります。
  1. PRでPlan結果をレビュー（差分の可視化）
  2. ApplyはCI/CD（権限と実行点の統制）
  3. 適用後に「意図しない差分がないか」を再Planで確認
- “決定的”でも、外部要因（手動変更、クラウド側仕様変更、API制限）で崩れるので、  
  **ロック**と**権限分離**がセットです（p10と表裏）。

---

## １２ 比較：Ansible vs Terraform
![te12.比較：Ansible対Terraform](/images/IaC/te12.比較：Ansible対Terraform.jpg)

### 図の要旨
- 役割（構成管理 vs プロビジョニング/オーケストレーション）
- 思想（手続き型 vs 宣言型）
- モデル（Mutable/Pets vs Immutable/Cattle）
- 得意フェーズ（Day2 vs Day0&1）
- 状態管理（Stateless vs Stateful）
を1枚で整理しています。

### 詳細解説（用語）
- **Stateless/Stateful（ここでの意味）**
  - Ansible：基本は“状態を持たず”毎回実機を見て作業（外部Stateを前提にしない）
  - Terraform：Stateを持って差分を計算（Stateの運用が必須）

### Tips（実務）
- 現場で揉めやすい論点は「どこまでをTerraformでやるか」です。  
  目安としては：
  - **クラウド資源の作成・結線**（VPC、LB、IAM、DB、DNS、監視）→ Terraform  
  - **OS内の設定・アプリ配布** → Ansible（またはイメージ焼き込み/コンテナ）
- “全部TerraformでOS設定まで”はできなくはないですが、  
  変更頻度と安全性を考えると、p14の分業が現実的です。

---

## １３ なぜ業界はシフトしたのか：マイクロサービスとコンテナ
![te13.なぜ業界はシフトしたのか：マイクロサービスとコンテナの台頭](/images/IaC/te13.なぜ業界はシフトしたのか：マイクロサービスとコンテナの台頭.jpg)

### 図の要旨
- Monolith（巨大一枚岩）から Microservices & Containers へ移り、ノード数が爆増＆短命化した結果、
  手作業・ペット運用が破綻しやすくなった、という背景説明です。
- さらにコンテナは本質的に“不変”と相性が良く、Terraformの思想と噛み合った、という指摘があります。

### 詳細解説（用語）
- **Monolith**：1つのデプロイ単位に機能が集約された構造。
- **Microservices**：小さなサービスに分割し、独立デプロイ・独立スケールする構造。
- **コンテナの不変性**：イメージを作って配る（実体にSSHして直す発想ではない）。

### Tips（実務）
- シフトの本質は「規模（Scale）」と「変更頻度（Change）」です。  
  ノード数×変更頻度が増えるほど、ドリフトと手作業が致命傷になります。
- コンテナ運用でも「基盤」は残ります（VPC、IAM、LB、監視…）。  
  ここをTerraformで“定義”しておくと、クラスターを作り替える時に強いです。

---

## １４ 共存の時代：Better Together
![te14.共存の時代：BetterTogether](/images/IaC/te14.共存の時代：BetterTogether.jpg)

### 図の要旨
- Terraformで基盤（Foundation）を作り、AnsibleやKubernetesマニフェストで上位（Config/Deployment）を管理する、
  という“分業レイヤー”の絵です。
- ひと言で「Terraformが家を建て、Ansibleが家具を配置する」。

### 詳細解説（用語）
- **Foundation Layer**：VPC、サブネット、ルーティング、セキュリティ、クラスター基盤など“下回り”。
- **Configuration Layer**：OS設定、ミドル設定、アプリ設定など“中身”。
- **Deployment Layer**：デプロイ（リリース）やスケール、ローリング更新。

### Tips（実務）
- 分業を成立させるコツ（超重要）
  - **境界の入力/出力を固定**する（例：TerraformのOutputでALB DNS、SG ID、Subnet IDを出す）
  - 上位はそのOutputを参照して動く（“手でコピペしない”）
  - 変更窓口（誰がどこを変えるか）を権限で分ける
- ここまで来ると、運用は「定義の更新→置換→検証」のループになります（p15）。

---

## １５ IaCの未来：管理から「定義」へ
![te15.IaCの未来：管理から「定義」へ](/images/IaC/te15.IaCの未来：管理から「定義」へ.jpg)

### 図の要旨
- Pets→Cattle、Scripting→Definingへ。
- 目的は「信頼（Confidence）」と「規模（Scale）」の両立。
- 最後の問いは、“あなたはクラウドをデータセンター（Pets）として扱いますか？それともユーティリティ（Cattle）として扱いますか？” です。

### 詳細解説（用語）
- **Defining（定義）**：状態をコードで固定し、そこに収束させる運用へ。
- **Confidence**：変更しても壊れない確信（Plan、テスト、段階リリース、監視が支える）。
- **Scale**：台数やサービス数が増えても、運用コストが線形に増えない状態。

### Tips（実務）
- “Cattle”に寄せるほど、必要になるのは技術より **プロセス**です。
  - 変更手順（Plan→Review→Apply）
  - 検証（自動テスト、監視、カナリア/段階リリース）
  - ルール（手作業の禁止/例外手順）
- 最終到達点は「再現できる」「捨てられる」「戻せる」。  
  迷ったらこの3つで設計判断するとブレません。

---
