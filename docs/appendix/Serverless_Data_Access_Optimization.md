# Serverless Data Access Optimization解説

## １ 資料全体の狙い（サーバーレス連携×DB設計）

![SD1.サーバレス連携基盤：最新アーキテクチャとDB設計手法](/images/gamehub/SD1.サーバレス連携基盤：最新アーキテクチャとDB設計手法.jpg)

### 図の要旨

大規模なサーバーレス連携基盤で、**データアクセス層をどう設計するか**（アプリ側に寄せるか、DB側に寄せるか）を扱い、特に**ストアドファンクション活用**を中心に最適化を示す導入図です。

### 解説

サーバーレス（例：Lambda）は「短時間・並列大量起動」が強みですが、DB接続や往復回数が増えると性能劣化しやすい傾向があります。そこで本資料は、**ロジック配置とSQL実装**を工夫し、ネットワーク往復や変換コストを減らして、処理全体を安定させる方針を示しています。

---

## ２ サーバーレス環境のDB接続（Lambda → RDS Proxy → Aurora）

![SD2.システム構成概要：サーバレス環境におけるDB接続](/images/gamehub/SD2.システム構成概要：サーバレス環境におけるDB接続.jpg)

### 図の要旨

API Gateway/SQS → Lambda → RDS Proxy（接続プーリング） → Aurora PostgreSQL、加えてキャッシュ（ElastiCache/Valkey）の位置づけを示しています。

### 解説

* **RDS Proxy**は、Lambdaの「急増する同時実行」でDB接続が爆増する問題（コネクション枯渇、接続確立コスト）を抑えるための“緩衝材”です。
* キャッシュ（Valkey等）は「頻繁に参照され、更新頻度が低い」データに有効ですが、更新が絡む整合性設計が必要になります。

### SQL深掘り（接続が安定すると何が嬉しいか）

DB接続が安定すると、次が効いてきます。

* **トランザクション境界**をアプリ側で安全に張れる（後述の9章）
* 1回のSQLで「まとめて処理」する設計（集合指向・一括処理）が活きる
* 余計なリトライやタイムアウトが減り、ロック競合も抑えやすい

---

## ３ ロジックはどこに置くべきか（Chatty回避）

![SD3.設計の分岐点：ロジックはどこに置くべきか？](/images/gamehub/SD3.設計の分岐点：ロジックはどこに置くべきか？.jpg)

### 図の要旨

* **アプリ側ロジック（非採用）**：往復が多い（Chatty）、Pythonループ処理、ネットワーク遅延
* **DB側ロジック（採用）**：データの近くで実行、高効率、整形済みJSONを一括返却

### 解説

サーバーレスでは、DBとアプリが別ネットワーク上にあり、**往復回数（Round-trip）** が性能を支配します。
同じ処理でも「1件ずつSELECT→加工→次へ」を繰り返すと、遅延が積み上がります。そこで、**DBで集合処理（set-based）** し、結果をそのまま返す設計が有効です。

### SQL深掘り：集合指向（set-based）とは

* 望ましい：`SELECT ... FROM ... WHERE ...` を**1回**で結果集合として取り、集約や整形もSQLで行う
* 避けたい：アプリ側で1行ずつ処理（いわゆる N+1 / 逐次処理）

---

## ４ ストアド利用のメリデメ比較（往復削減・JSON直返し）

![SD4.ストアドファンクション利用のメリットとデメリット比較](/images/gamehub/SD4.ストアドファンクション利用のメリットとデメリット比較.jpg)

### 図の要旨

アプリ側処理とストアド（DB側）処理を比較し、特に

* 往復回数（遅延）
* DB内データ処理効率
* JSON生成（レスポンス形式）
  でストアド中心が有利、という主張です。

### 解説（重要な注意）

「何でもDB側に寄せる」ではなく、狙いは **“往復と変換の削減”**です。
また、ストアドは**トランザクション制御（COMMIT/ROLLBACK）を内部に持たない**方が再利用性が上がる、という設計思想が後半（９章）につながります。

### SQL深掘り：JSON直返しが効く理由

アプリ側で `Row → dict → JSON` と変換するより、DB側で `json_agg` 等を使い **APIレスポンス用JSONを生成**すると、

* 変換コスト削減
* スキーマをSQL側で保証しやすい
* 返却形式が安定しやすい
  という利点が出ます（ただし、SQLが複雑化しすぎないよう注意）。

---

## ５ ストアドファンクションの基本構造（命名・共通引数・JSON返却）

![SD5.ストアドファンクションの基本構造（Anatomy）](/images/gamehub/SD5.ストアドファンクションの基本構造（Anatomy）.jpg)

### 図の要旨

ストアド設計の作法として、

* 命名規則（prefix＋動詞、スネークケース等）
* 共通引数（呼び出し元・実行者などの監査用メタ情報）
* 戻り値はJSON（構造化）
  を推奨しています。

### 解説

実務上、ストアドを“資産化”するには次が効きます。

* **一貫した命名**：何をする関数かが見える（select/insert/update等）
* **監査性**：誰が何をしたかを記録しやすい（ログ・監査列）
* **戻り値の統一**：アプリ側が扱いやすい（成功可否、件数、データ）

### SQL深掘り：JSON vs JSONB

PostgreSQLでは `json` と `jsonb` があり、一般に

* `jsonb`：内部表現が最適化され、検索・演算に強い（多くのケースで推奨）
* `json`：入力のテキスト表現を保持
  用途に応じて選びますが、API返却とDB内演算が絡むなら `jsonb` を検討することが多いです。

---

## ６ SELECTからJSON配列を作る（row_to_json → json_agg → COALESCE）

![SD6.初心者向けSQL解説：SELECTとJSON生成の魔術](/images/gamehub/SD6.初心者向けSQL解説：SELECTとJSON生成の魔術.jpg)

### 図の要旨

1行→JSON化（`row_to_json`）、複数行→配列集約（`json_agg`）、結果0件→空配列（`COALESCE`）の流れです。

### 代表パターン（一般化）

```sql
SELECT COALESCE(json_agg(row_to_json(t)), '[]'::json) AS data
FROM (
  SELECT col1, col2
  FROM some_table
  WHERE ...
) AS t;
```

### SQL深掘り（実務で押さえるポイント）

* **順序保証**：配列の並び順が要件なら `json_agg(...) ORDER BY ...`（PostgreSQLの書き方に注意）
* **必要な列だけ返す**：`SELECT *` を避け、API契約に必要な列に絞る
* **json_build_object の活用**：列名を明示してAPIスキーマを安定化
  例：

```sql
SELECT COALESCE(
  json_agg(json_build_object('id', id, 'name', name)),
  '[]'::json
) AS data
FROM some_table;
```

---

## ７ 配列を使った一括登録（UNNEST・採番・RETURNING）

![SD7.初心者向けSQL解説：配列を使った一括登録（BulkInsert）](/images/gamehub/SD7.初心者向けSQL解説：配列を使った一括登録（BulkInsert）.jpg)

### 図の要旨

* 入力を配列で受け取る
* `UNNEST` で行に展開
* `ROW_NUMBER()` 等で採番
* `RETURNING` で登録結果をそのまま返す
  という一括Insertの定石です。

### 代表パターン（一般化）

```sql
INSERT INTO target_table(seq_no, value)
SELECT
  base_seq + ROW_NUMBER() OVER (ORDER BY 1),
  x.value
FROM UNNEST(p_values) AS x(value)
RETURNING *;
```

### SQL深掘り：一括登録の設計注意

* **採番はシーケンス推奨**：手動で `MAX()+ROW_NUMBER()` は競合しやすい（同時実行で衝突）

  * 可能なら `nextval('seq')` を使う
* **UNNESTの順序**：配列順を保持したい場合は `WITH ORDINALITY` を検討
  例：

```sql
SELECT value, ord
FROM UNNEST(p_values) WITH ORDINALITY AS t(value, ord)
ORDER BY ord;
```

---

## ８ エラーハンドリングと標準レスポンス（SQLSTATE・安全なJSON返却）

![SD8.エラーハンドリングと標準レスポンス形式](/images/gamehub/SD8.エラーハンドリングと標準レスポンス形式.jpg)

### 図の要旨

SQL例外を `WHEN OTHERS` 等で捕捉し、SQLSTATEなどの診断情報を集め、**標準JSON**（success/err_code/err_msg/row_count/data）で返す方針です。

### 解説

ストアド内で例外を“握りつぶす”のではなく、**アプリ側が判断できる形に整形して返す**のがポイントです。
ただし、例外を捕捉して正常終了してしまうと、呼び出し側のトランザクション設計と矛盾することがあります。運用方針として、

* 「例外は投げる（アプリ側でROLLBACK）」
* 「例外はJSONにして返す（アプリ側で分岐）」
  のどちらかを統一するのが重要です。

### SQL深掘り：診断情報の取り方（PostgreSQL）

PL/pgSQLでは診断情報を取り出せます（一般論）：

* `SQLSTATE`：エラー種別コード
* `SQLERRM`：エラーメッセージ
* `GET STACKED DIAGNOSTICS`：詳細（制約名など）
  これらをログ・監査に活かすと復旧が容易になります。

---

## ９ トランザクション管理の境界（COMMIT/ROLLBACKはアプリ側）

![SD9.トランザクション管理の境界線](/images/gamehub/SD9.トランザクション管理の境界線.jpg)

### 図の要旨

* ストアド内に `COMMIT/ROLLBACK` を書かない（禁止）
* アプリ（Lambda）側で複数ストアド呼び出しを1単位としてBEGIN→COMMIT/ROLLBACKする
  という境界線を示しています。

### 解説（なぜこの分離が良いか）

* **再利用性**：ストアドが「勝手にコミット」すると、他の処理と組み合わせづらい
* **可観測性**：アプリ側で「どの操作の集合を1トランザクションにするか」を制御できる
* **業務フローの柔軟性**：A→B→条件判定→C のような分岐をアプリ側で組める

### SQL深掘り：関数/手続きとトランザクション

PostgreSQLでは一般に「関数（FUNCTION）」はトランザクションを完了させません。
「手続き（PROCEDURE）」は構文上トランザクション制御を伴う設計が可能な場合がありますが、**運用一貫性と再利用性**の観点で、あえてアプリ側に寄せる設計は合理的です。

---

## １０ Python（Lambda）からの呼び出し（ストアド実行→レスポンス判定）

![SD10.Puthon実装：Lambdaからの呼び出し](/images/gamehub/SD10.Puthon実装：Lambdaからの呼び出し.jpg)

### 図の要旨

Lambda側は「交通整理（オーケストレーション）」に徹し、

* パラメータ整形
* DB呼び出し
* 返却JSON（success等）判定
* 失敗時は例外化
  という責務分離を示しています。

### 解説

ここでの要点は「アプリはループでDBをいじらない」ではなく、

* **DBにまとめてやらせる**
* アプリは **制御・検証・例外処理** に集中する
  という役割分担です。

### SQL深掘り：戻り値設計の定石

ストアドがJSONを返す場合、最低限以下があるとアプリが安定します。

* `success`（成功/失敗区分）
* `row_count`（影響件数）
* `data`（配列またはオブジェクト）
* `err_code/err_msg`（失敗時）
  ※命名は任意ですが、全関数で揃えるのが重要です。

---

## １１ 入力検証 “Fail Fast”（API→Lambda→DBの段階分離）

![SD11.入力検証：FailFast（早期失敗）の原則](/images/gamehub/SD11.入力検証：FailFast（早期失敗）の原則.jpg)

### 図の要旨

* API Gateway：型/必須/フォーマットなど基本検証
* Lambda：複合条件などの詳細検証（失敗は400）
* DB：整合性前提でビジネスロジック実行
  という「左で落とす」設計です。

### 解説

サーバーレスでは1回の無駄なDB往復でもコストと遅延が出ます。
そのため **不正入力はできるだけ早く落とす**のが合理的です。

### SQL深掘り：DB側バリデーションの扱い

DBの制約（NOT NULL、FK、CHECKなど）は最後の砦ですが、
「ユーザーに分かりやすいエラー」を返したい場合はアプリ側でも検証します。
理想は、

* アプリ：ユーザー向けエラー
* DB：データ破壊防止（強制）
  の二段構えです。

---

## １２ 品質保証（テスト戦略とカバレッジ）

![SD12.品質保証：テスト戦略とカバレッジ](/images/gamehub/SD12.品質保証：テスト戦略とカバレッジ.jpg)

### 図の要旨

実装（Python+SQL）→ pytest 等での統合テスト → カバレッジレポート（目標例：90%）という品質フローです。

### 解説

ストアド中心設計では「SQLロジック」も重要なプロダクトコードです。したがって、

* 正常系（データ投入→期待JSON）
* 異常系（制約違反、想定外エラー、ロールバック）
  を自動テストで担保する必要があります。

### SQL深掘り：テストで見るべき観点

* **影響件数**（INSERT/UPDATE/DELETEの件数が想定通りか）
* **整合性**（トランザクションの途中失敗で中途半端に残らないか）
* **境界値**（空配列、NULL、最大長、重複など）
* **並行性**（採番や一括登録が競合しないか）

---

## １３ まとめ（往復削減・JSON中心・標準化・責務分離）

![SD13.まとめ：高効率な開発のために](/images/gamehub/SD13.まとめ：高効率な開発のために.jpg)

### 図の要旨

1. Round-trip削減
2. JSON-centric設計（DBでJSON生成）
3. 標準化（命名・共通パラメータ）
4. 責務分離（トランザクション＝アプリ、データ操作＝DB）
   を総括しています。

### 解説（実務の結論）

この資料の設計思想は「DBに閉じ込める」ではなく、**分散環境（サーバーレス）で性能・保守性・整合性を同時に取りにいく**ための現実解です。
特に効くのは次の2点です。

* 往復を減らす（ネットワーク遅延の削減）
* 変換を減らす（JSON生成の一元化）

---

# 付録：SQL一般論の深掘り（必要に応じて本文からリンク）

## A) “速いSQL”の基本（サーバーレスで効く順）

* **往復回数を減らす**：N回SELECTを1回にまとめる（JOIN/集約/IN/UNNEST）
* **必要列だけ取る**：`SELECT *` を避ける
* **集合処理に寄せる**：アプリのforループをSQLへ
* **シーケンス活用**：`MAX()+1` のような採番は競合しやすい
* **インデックス設計**：WHERE/JOIN/ORDER BY に効く列を中心に

## B) JSON生成の定石（PostgreSQL）

* 配列：`json_agg` / `jsonb_agg` ＋ `COALESCE(...,'[]')`
* オブジェクト：`json_build_object` / `jsonb_build_object`
* ネスト：サブクエリで子要素を `json_agg` して親に埋め込む（ただし複雑化に注意）

---

次回以降に解説検討中

* **“JSON生成SQLのテンプレ集”**（よく使う形をコピペ可能に）
* **“一括登録（UNNEST/ORDINALITY/RETURNING）テンプレ集”**
* **“例外処理（SQLSTATE/診断情報/ログ設計）テンプレ集”**
