## １ タイトル：良いAPIから素晴らしいAPIへ

![Rem1.RESTAPをレベルアップ：よいAPIから素晴らしいAPIへ](/images/REST/Rem1.RESTAPをレベルアップ：よいAPIから素晴らしいAPIへ.jpg)

### 図の要点
- 「動く」だけのAPI（Functional）から、**使いやすく壊れにくいAPI（Great）** へ。
- ここで言う “レベルアップ” は、派手な機能追加ではなく **開発者体験（DX）** と **運用耐性** を上げること。

### 初心者向け：用語
- **REST API**：HTTPを使って「リソース（名詞）」を操作する設計スタイル。
- **DX（Developer Experience）**：API利用者（他チーム/外部/未来の自分）が迷わず使える体験。
- **運用耐性**：障害・リトライ・負荷・変更に強いこと。

### Tips（実務で効く）
:::tip
「APIは開発者向けUI」です。  
画面UIと同じく、**一貫性・わかりやすさ・失敗しにくさ**が品質になります。
:::

---

## ２ 良いAPIと素晴らしいAPIの差

![Rem2.「機能するAPI」と「素晴らしいAPI」の違い](/images/REST/Rem2.「機能するAPI」と「素晴らしいAPI」の違い.jpg)

### 図の要点
- Great API は、だいたい次を満たします：
  - **予測できる**（命名やレスポンス形式が統一）
  - **信頼できる**（正しいHTTPステータス、衝突/二重実行に強い）
  - **スケールできる**（ページング、レート制限、キャッシュ等）

### 初心者向け：用語
- **予測可能性**：同じパターンなら同じ結果が返る（例：エラー形式が毎回同じ）。
- **信頼性**：リトライしても壊れない・変な成功にならない。
- **スケーラビリティ**：データ量/利用者増に耐える設計（ページング、制限、キャッシュ）。

### Tips
- “とりあえず動く” の次に来るのが、**「チームが楽になる」API**です。
- 仕様書に書くべきは機能だけでなく、**失敗時・競合時・負荷時**のふるまい。

---

## ３ リソース設計：動詞ではなく名詞

![Rem3.リソース設計：同士でなく名刺を使う](/images/REST/Rem3.リソース設計：同士でなく名刺を使う.jpg)

### 図の要点
- URLに操作（動詞）を書く「RPC風」から卒業する。
  - ❌ `POST /createUser` / `GET /getAllOrders`
  - ✅ `POST /users` / `GET /orders`
- ルール：
  - **複数形**を使う：`/user` ではなく `/users`
  - **ネストは浅く**：推奨は2階層程度（例：`/users/123/orders`）

### 初心者向け：用語
- **リソース**：APIが扱う“もの”（ユーザー、注文、商品…）。
- **RPC style**：`doSomething` のように「操作」をURLに出す設計。
- **REST style**：URLは「もの」、操作はHTTPメソッドで表現。

### Tips（例）
- 「注文作成」は `/createOrder` ではなく：
  - `POST /orders`（注文というリソースを“作る”）
- 「ユーザーBAN」は悩みどころですが、基本は状態遷移：
  - `PATCH /users/{id}` with `{ "status": "banned" }`
  - どうしても“操作”ならサブリソースに逃がす：`POST /users/{id}/ban`（例外扱いで最小に）

---

## ４ HTTPメソッドを正しく使う

![Rem4.HTTPメソッドのセマンティックスと安全性](/images/REST/Rem4.HTTPメソッドのセマンティックスと安全性.jpg)

### 図の要点
- **GETで状態変更しない**（キャッシュ/リンクプレビュー等で事故る）
- メソッドの役割（超重要）：
  - **GET**：取得（安全：副作用なし）
  - **POST**：作成/実行（非冪等になりがち）
  - **PUT**：全置換（冪等）
  - **PATCH**：部分更新（冪等に設計できる）
  - **DELETE**：削除（冪等）

### 初心者向け：用語
- **安全（safe）**：呼んでも状態が変わらない（GETが代表）。
- **冪等（idempotent）**：同じリクエストを何回送っても結果が同じ（PUT/DELETEなど）。
- **副作用**：データが増える、状態が変わる、課金が走る等。

### Tips
:::warning
「更新なのにPOST」は後で事故りやすいです（キャッシュ、リトライ、重複実行）。
まず PUT/PATCH で表現できないか検討すると安全になります。
:::

---

## ５ エラーハンドリング：200で返さない

![Rem5.エラーハンドリング：２００OKでえらーを返さない](/images/REST/Rem5.エラーハンドリング：２００OKでえらーを返さない.jpg)

### 図の要点
- エラーは **200 OK** で返さない。HTTPステータスで意味を伝える。
- 推奨：**Problem Details（RFC 9457）** 形式で統一する。

### 初心者向け：用語
- **HTTPステータス**：成功/失敗の種類を表す番号（例：400, 401, 404, 409, 500）。
- **Problem Details**：エラーの共通JSONフォーマット（`type/title/status/detail` など）。

### Tips（実務テンプレ）

{
  "type": "https://example.com/problems/validation-error",
  "title": "Validation failed",
  "status": 400,
  "detail": "email is invalid",
  "instance": "/users"
}


よく使うステータスの目安：

* **400**：入力不正（バリデーション）
* **401**：未認証（ログインしてない/トークンなし）
* **403**：権限なし（ログインはしてるが禁止）
* **404**：対象なし
* **409**：競合（同時更新、重複作成）
* **429**：レート超過
* **500**：サーバ内部（詳細は漏らしすぎない）

---

## ６ 命名規約とデータ表現を統一

![Rem6.命名規約とデータフォーマットの一貫性](/images/REST/Rem6.命名規約とデータフォーマットの一貫性.jpg)

### 図の要点

* URL/JSON/日時など、**表現の一貫性**はDXを直撃します。
* 例：

  * JSONは `camelCase`（推奨）に統一
  * 日時は **ISO 8601**（例：`2026-02-08T10:15:00+09:00`）
  * Content-Type は `application/json`

### 初心者向け：用語

* **camelCase**：`createdAt` のように単語境界を大文字で表す。
* **ISO 8601**：日時表現の国際標準（タイムゾーン込みが安全）。
* **Content-Type**：ボディの形式（JSONなら `application/json`）。

### Tips

* 「レスポンスの包み（envelope）」はプロジェクト方針次第ですが、**エラー形式だけでも統一**すると運用が楽です。
* 日時は“必ず”タイムゾーンを含める（サマータイム・海外対応で詰まらない）。

---

## ７ ページネーション：Offset vs Cursor

![Rem7.ページネーション：Offset方式対Cursor方式](/images/REST/Rem7.ページネーション：Offset方式対Cursor方式.jpg)

### 図の要点

* **Offset方式**：`?page=3&limit=20` のようにページ番号で移動（実装は簡単）

  * 欠点：大量データで遅くなりやすい／途中挿入・削除でズレる
* **Cursor方式**：`?limit=20&cursor=eyJpZCI6...` のように“続き”を指す

  * 利点：安定・高速になりやすい（大規模向き）

### 初心者向け：用語

* **offset**：先頭から何件スキップするか。
* **cursor**：次の取得開始位置を表すトークン（多くはIDや時刻を元に生成）。
* **limit**：1回の取得件数。

### Tips（現場の判断基準）

* 数百〜数千件程度なら Offset でも許容されることが多い
* 数万件以上／継続スクロールUI／監査ログ等は Cursor を推奨

カーソルレスポンス例（雰囲気）：

```json
{
  "items": [ ... ],
  "nextCursor": "eyJz..."
}
```

---

## ８ 検索API：フィルタ・ソート・部分取得

![Rem8.フィルタリング、ソート、部分レスポンス](/images/REST/Rem8.フィルタリング、ソート、部分レスポンス.jpg)

### 図の要点

* 検索・一覧APIは「使いやすさ」が差になります。

  * Filter：`?status=active&category=tech`
  * Sort：`?sort=-createdAt`（先頭の`-`で降順など）
  * Fields（部分取得）：`?fields=id,name,email`
  * Expand（関連展開）：`?expand=orders`（使いすぎ注意）

### 初心者向け：用語

* **フィルタ**：条件で絞り込み
* **ソート**：並び替え
* **部分取得**：必要な項目だけ返す（転送量・表示速度に効く）
* **N+1問題**：関連データを都度取りに行って遅くなる問題（expand設計で出やすい）

### Tips

---

## ９ 二重作成防止：Idempotency-Key

![Rem9.冪等性（Idempotency）：リトライを安全に](/images/REST/Rem9.冪等性（Idempotency）：リトライを安全に.jpg)

### 図の要点

* ネットワークは失敗するので、クライアントは**リトライ**します。
* その結果、`POST /payments` が二重実行されると事故になる。
* 解決：**Idempotency-Key** を導入（同じキーなら同じ結果を返す）

### 初心者向け：用語

* **リトライ**：タイムアウト時に再送すること。
* **二重実行**：同じ処理が2回走る（課金・注文・メール送信で致命傷）。
* **Idempotency-Key**：重複検知のためのクライアント生成キー。

### Tips（実装の勘所）

* リクエストヘッダ：`Idempotency-Key: <uuid>`
* サーバ側は「キー＋ユーザー＋エンドポイント」等で結果を一定期間保存
* 同じキーで来たら **同じレスポンス** を返す（ステータスも含める）

---

## １０ 競合対策：ETag と If-Match

![Rem10.並行制御：ETagによる楽観的ロック](/images/REST/Rem10.並行制御：ETagによる楽観的ロック.jpg)

### 図の要点

* 同時編集で「後勝ち（last write wins）」になるとデータが壊れる。
* 解決：**楽観的ロック**（Optimistic Concurrency）

  * `GET` の結果に `ETag` を返す
  * 更新時に `If-Match` で “自分が見た版” を指定
  * ずれていたら更新拒否（409/412）

### 初心者向け：用語

* **ETag**：リソースの版を表す識別子（ハッシュやversion番号）。
* **If-Match**：更新条件ヘッダ。「このETagと一致するなら更新していい」。
* **楽観ロック**：衝突は稀だと仮定し、更新時に検知して止める方式。

### Tips（雰囲気の例）

```http
GET /orders/123
ETag: "v3"
```

```http
PUT /orders/123
If-Match: "v3"
```

* 一致しない場合：`412 Precondition Failed`（代表的）
* 返すエラーは p05 の Problem Details 形式に揃えると美しい

---

## １１ レート制限：429 と RateLimit ヘッダ

![Rem11.レート制限：拒否するだけでなく情報を与える](/images/REST/Rem11.レート制限：拒否するだけでなく情報を与える.jpg)

### 図の要点

* APIは無限に受けられない（障害・コスト・他ユーザー影響）
* レート制限時は **429 Too Many Requests**
* 返すべき情報：

  * `Retry-After`
  * `X-RateLimit-Limit / Remaining / Reset`（または標準系のRateLimitヘッダ）

### 初心者向け：用語

* **レート制限**：一定時間内の呼び出し回数を制限する仕組み。
* **バックオフ**：失敗時に待ち時間を伸ばして再試行すること。
* **スロットリング**：混雑時に意図的に落とす/遅らせること。

### Tips

* クライアント側は「即時連打」ではなく、**指数バックオフ**＋ジッターが基本。
* サーバ側は「誰を守るための制限か」を明確に（ユーザー単位/トークン単位/IP単位）。

---

## １２ セキュリティ：エラーは攻撃面

![Rem12.セキュリティ：レスポンスは攻撃対象領域](/images/REST/Rem12.セキュリティ：レスポンスは攻撃対象領域.jpg)

### 図の要点

* エラー詳細は便利だが、出し過ぎると攻撃に使われる。

  * スタックトレースや内部DB名、詳細例外は外に出さない
* セキュリティヘッダの例：

  * HSTS、CSP、`X-Content-Type-Options` 等

### 初心者向け：用語

* **情報漏えい**：内部構造（ライブラリ/テーブル/パス）を推測されること。
* **HSTS**：HTTPS強制（中間者攻撃対策）
* **CSP**：コンテンツ読み込み制限（XSS対策）

### Tips

* なし

## １３ バージョニングと互換性戦略

![Rem13.バージョニング：進化に備える](/images/REST/Rem13.バージョニング：進化に備える.jpg)

### 図の要点

* バージョンは増やすほど運用コストが増える。むやみに切らない。
* 代表方式：

  * URL：`/v1/users`
  * ヘッダ：`Accept: application/vnd.xxx.v1+json`
* 重要：**非互換変更**のときだけ慎重に。基本は“追加”で後方互換を保つ。

### 初心者向け：用語

* **後方互換**：古いクライアントが壊れない変更（項目追加など）。
* **非互換変更（breaking change）**：クライアントが壊れる変更（必須項目追加、型変更など）。
* **廃止（deprecation）**：旧版を段階的に止める運用。

### Tips（運用の型）

* 互換維持 → 旧版に警告ヘッダ → 移行期限告知 → 並行提供 → 停止
* 期限や移行ガイドがない“突然死”は、APIの信用を一撃で落とします

---

## １４ ドキュメントはAPIのUI（OpenAPI）

![Rem14.ドキュメント：APIのユーザインターフェース](/images/REST/Rem14.ドキュメント：APIのユーザインターフェース.jpg)

### 図の要点

* ドキュメントが薄いAPIは「使えないAPI」になりがち。
* OpenAPI/Swagger で：

  * エンドポイント、スキーマ、例、エラー、認証、制限（429）まで書く
  * Try it out（試せる）形が強い

### 初心者向け：用語

* **OpenAPI**：API仕様を機械可読で記述する標準（Swaggerの中身）。
* **SDK**：呼び出しコードを自動生成して利用者負担を下げる仕組み。
* **Changelog**：変更履歴（互換性の説明が大事）。

### Tips

* 仕様に必ず入れるべき“最低限セット”

  * 正常系の例（request/response）
  * エラー例（Problem Details）
  * 認証方法（401/403の意味）
  * ページング・ソート・制限（429/Retry-After）
  * 競合（ETag/If-Match）と二重実行対策（Idempotency-Key）

---

## １５ まとめ：Level Up チェックリスト

![Rem15.「素晴らしいAPI」へのチェックリスト](/images/REST/Rem15.「素晴らしいAPI」へのチェックリスト.jpg)

### 図の要点（チェックリスト化）

* URLはリソース（名詞）、複数形、ネスト浅く
* HTTPメソッドとステータスを正しく
* エラーは統一フォーマット（Problem Details）
* 大量データは Cursor ページング
* 二重実行に Idempotency-Key
* 同時更新に ETag / If-Match
* レート制限は 429 + ヘッダ
* セキュリティは“出しすぎない”＋ヘッダ
* バージョン運用は慎重に（互換性優先）
* ドキュメントはAPIのUI（OpenAPI + 例 + 運用仕様）

### ここからの実務アクション（おすすめ順）

1. **エラー形式（５章）** を統一（最短で効果が出る）
2. 一覧APIに **ページング（７章）** と **フィルタ/ソート（８章）**
3. 更新・作成系に **Idempotency/ETag（９章/１０章）**
4. 公開/社内展開に合わせて **429（１１章）** と **OpenAPI（１４章）**
5. 最後に **version/deprecation（１３章）** を運用設計として固める

```
::contentReference[oaicite:0]{index=0}
```
