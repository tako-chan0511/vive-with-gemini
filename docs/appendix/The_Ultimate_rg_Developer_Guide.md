## １　導入：rgで「検索」を「体験」に変える

![rg1.開発者必携！rg（ripgrep）活用ユースケースTop10](/images/gamehub/rg1.開発者必携！rg（ripgrep）活用ユースケースTop10.jpg)

### 図の要旨

* タイトル：開発者必携！rg（ripgrep）活用ユースケース Top10
* メッセージ：**高速・スマート・設定不要**。grep を超えた大規模検索のスタンダード。

### 詳細解説

rgは「grep互換の検索ツール」ですが、実務では **“コードベース全体を探索するための高速なインデックス代替”** のように使われます。特に次の3点が強みです。

* **速い**：大規模リポジトリでも耐える
* **賢い**：`.gitignore` などを尊重してノイズを減らす
* **すぐ使える**：プロジェクト直下で `rg` と打つだけ

### Tips：最初に覚える3コマンド

```bash
rg 'word'                 # まずはこれ
rg -n 'word'              # 行番号も付ける（レビュー・共有に便利）
rg -S 'Word'              # Smart case（小文字なら無視/大文字混じりなら区別）
```

---

## ２　なぜ grep ではなく rg なのか

![rg2.なぜgrepでなくrgなのか？](/images/gamehub/rg2.なぜgrepでなくrgなのか？.jpg)

### 図の要旨（3つの理由）

1. 圧倒的な検索速度（Rust製・並列処理）
2. 「見たくないもの」を自動無視（`.gitignore` を読む）
3. 設定不要で即戦力（デフォルトで再帰検索）

### 詳細解説

* **grepはファイル探索を自分で組み立てる必要**があり、`find ... | xargs grep ...` のように“儀式”が増えがちです。
* rgは **探索＋検索が一体**で、プロジェクト直下で即戦力になります。

### Tips：grep的に使いたいとき

```bash
rg -F 'literal'   # 正規表現ではなく固定文字列として扱う（= grep -F 相当）
rg -i 'word'      # 大小文字無視
rg -w 'word'      # 単語境界（変数名の誤ヒット抑制）
```

---

## ３ 迷ったらこれ：設定不要のプロジェクト全体検索

![rg3.迷ったらこれ.設定不要のプロジェクト全体検索](/images/gamehub/rg3.迷ったらこれ.設定不要のプロジェクト全体検索.jpg)

### 図の要旨

```bash
rg '検索したい語句'
```

* カレントディレクトリ配下を再帰検索
* `.gitignore`（例：`node_modules` 等）を自動で除外

### 詳細解説

この使い方が“最強”な理由は、**検索対象の設計をrgに委ねられる**点です。
巨大リポジトリほど「探す対象を絞る」コストが効いてくるため、まず `rg` 一発で当たりを付けるのが合理的です。

### Tips：検索の精度を上げる（まずはここ）

```bash
rg -S 'UserId'        # 大文字混じりなら大小区別で精度UP
rg -g'*.py' 'TODO'    # 対象を拡張子で絞る
rg -g'!*.test.*' ...  # 除外もできる
```

---

## ４ ノイズを減らす：特定のファイルだけを狙い撃ち

![rg4.検索ノイズを減らす.特定ファイルだけを狙い撃ち](/images/gamehub/rg4.検索ノイズを減らす.特定ファイルだけを狙い撃ち.jpg)

### 図の要旨

```bash
rg -g '*.ts' 'import'
rg -g '!* .test.ts' 'function'   # 画像は「テスト除外」の例（glob否定）
```

### 詳細解説

* `-g` は **glob（ファイルパターン）**で検索対象を制御します。
* “テストやドキュメントが邪魔”という状況で効きます。

### Tips：`-g`より強力な「type」も覚える

rgには言語別の type（例：`py`, `js`, `ts` など）があり、環境によってはこれが楽です。

```bash
rg --type py 'pattern'
rg --type-add 'backend:*.py' --type backend 'pattern'
```

---

## ５ ファイルを開かずに「前後」を読む（文脈表示）

![rg5.ファイルを開かずに「前後」を読む](/images/gamehub/rg5.ファイルを開かずに「前後」を読む.jpg)

### 図の要旨

```bash
rg -C 5 'エラーメッセージ'
```

* 前後5行のコンテキスト付きで表示

### 詳細解説

ヒット行だけでは「原因・前提・後続処理」が分からないことが多いです。`-C` で **周辺を一緒に読む**と、エディタを開く回数が激減します。

### Tips：前だけ/後ろだけ

```bash
rg -B 5 'pattern'   # Before（前だけ）
rg -A 5 'pattern'   # After（後ろだけ）
```

---

## ６ 「中身」ではなく「ファイル名」を知りたい

![rg6.「中身」ではなく「ファイル名」を知りたい](/images/gamehub/rg6.「中身」ではなく「ファイル名」を知りたい.jpg)

### 図の要旨

```bash
rg -l 'TODO'
```

* マッチした「行」ではなく **ファイル名だけ**を出す（files-with-matches）

### 詳細解説

`-l` は次の処理（lint・集計・一括処理）の起点になります。
「どのファイルにTODOがあるか」→「それを一覧化してタスク化」などに直結します。

### Tips：逆（マッチしないファイル）

```bash
rg -L 'Copyright'   # files-without-match
```

---

## ７ 正規表現のエスケープ地獄からの解放（固定文字列 -F）

![rg7.正規表現のエスケープ地獄からの解放](/images/gamehub/rg7.正規表現のエスケープ地獄からの解放.jpg)

### 図の要旨

* 正規表現で記号を探すのは辛い
* `-F`（Fixed string）で **文字列をそのまま検索**できる

例（図の主旨）：

```bash
rg -F 'array[*]'
```

### 詳細解説

正規表現では `[]()*+?.` などに意味があり、意図せず“パターン”になってしまいます。
**記号を含む文字列・コード片を探すときは -F が最強**です。

### Tips：`-F`を使う判断基準

* 文字列を **“そのまま”**探したい → `-F`
* 変数名の揺れ、部分一致など **パターン**で探したい → 正規表現

---

## ８ 部分一致の誤ヒットを防ぐ（単語境界 -w）

![rg8.部分一致による誤ヒットを防ぐ](/images/gamehub/rg8.部分一致による誤ヒットを防ぐ.jpg)

### 図の要旨

```bash
rg -w 'user'
```

* `user` は欲しいが `username` や `superuser` は不要、という状況で使う

### 詳細解説

`-w` は「単語境界」で一致を絞るため、**変数名・識別子探索**に向いています。
リファクタ前の影響範囲調査でも誤ヒットが激減します。

### Tips：より厳密に“識別子”を探す

言語によっては単語境界より「識別子境界（英数＋_）」が欲しいことがあります。

```bash
rg -n --pcre2 '(?<![A-Za-z0-9_])user(?![A-Za-z0-9_])'   # ※PCRE2が必要な場合あり（後述）
```

---

## ９ ログ解析：必要なデータだけ抜き出す（-o）

![rg9.ログ解析に最適、必要なデータだけを抜き出す](/images/gamehub/rg9.ログ解析に最適、必要なデータだけを抜き出す.jpg)

### 図の要旨

```bash
rg -o '([0-9]{1,3}\.){3}[0-9]{1,3}' 
```

* 行全体ではなく **マッチ部分だけ**出す（only-matching）

### 詳細解説

`-o` は「抽出」に使えます。
ログからIP、ID、トレースIDなどを抜き出して、次の集計（sort/uniq）に繋げられます。

### Tips：集計の黄金パイプライン

```bash
rg -o '([0-9]{1,3}\.){3}[0-9]{1,3}'  \
| sort | uniq -c | sort -nr | head
```

---

## １０ PCRE2：高度なパターンマッチ（先読み・Unicode）

![rg10.PCRE2エンジンによる高度なパターンマッチ](/images/gamehub/rg10.PCRE2エンジンによる高度なパターンマッチ.jpg)

### 図の要旨

* Lookaround（先読み/後読み）など高度機能 → `--pcre2`
* Unicodeプロパティで「漢字など」を厳密検出

例（図の主旨）：

```bash
rg --pcre2 'consul(?!t)'      # consul は欲しいが consult を除外
rg --pcre2 '\p{sc=Han}'       # 漢字（Han script）検出
```

### 詳細解説

rgのデフォルト正規表現エンジン（Rust regex）は高速ですが、**lookaroundが使えない**など制約があります。
`--pcre2` は機能が豊富な代わりに、ケースによっては遅くなるため「必要なときだけ」使うのがコツです。

### Tips：日本語混在の検出に応用

* “日本語（ひらがな/カタカナ/漢字）が入っている行を拾う”

```bash
rg --pcre2 '[\p{sc=Hiragana}\p{sc=Katakana}\p{sc=Han}]'
```

---

## １１ 複数行にまたがるコードブロックを探す（-U）

![rg11.行をまたぐコードブロックを見つける](/images/gamehub/rg11.行をまたぐコードブロックを見つける.jpg)

### 図の要旨

```bash
rg -U 'BEGIN(\n|.)*END'
```

* 複数行にまたがるパターンを探す（multi-line）

### 詳細解説

通常の検索は「1行単位」です。
`-U` は複数行マッチを可能にし、ブロック構造の検出（BEGIN〜END、タグの塊、設定ブロック等）で威力を発揮します。

### Tips：性能注意（実務の扱い）

* `-U` は強力ですが、対象が大きいと重くなりがちです。
* **ファイル種別を絞る**・**起点文字列で絞る**のが実務的です。

```bash
rg -U -g'*.sql' 'BEGIN(\n|.)*END'
```

---

## １２ 一括置換（応用）：検索→ファイル抽出→置換

![rg12.検索結果を一括置換する（応用編）](/images/gamehub/rg12.検索結果を一括置換する（応用編）.jpg)

### 図の要旨（典型）

```bash
rg -l '旧名' | xargs sed -i 's/旧/新/g'
```

### 詳細解説（重要：安全策込み）

この手法は強力ですが、**ファイル名に空白がある**、**対象が膨大**、**誤置換**などの事故が起きやすい領域です。
実務では、次の「安全形」を推奨します。

#### 推奨：NUL区切りで安全に渡す

```bash
rg -l --null 'OldClass' \
| xargs -0 sed -i 's/OldClass/NewClass/g'
```

#### 推奨：置換前に“対象だけ”を確認

```bash
rg -n 'OldClass'          # まずヒット箇所を見る
rg -l 'OldClass' | head   # 対象ファイルをざっと見る
```

#### 推奨：Git運用とセットで

* 置換前にブランチを切る
* 置換後は `git diff` で差分レビュー
* 想定外なら即戻す（`git restore` 等）

---

## １３　トラブルシュート：「検索に出ない」と思ったら

![rg13.トラブルシュート：検索に出ないと思ったら](/images/gamehub/rg13.トラブルシュート：検索に出ないと思ったら.jpg)

### 図の要旨（3パターン）

1. `.gitignore` で無視されている → `--no-ignore`
2. 隠しファイル（.env 等） → `--hidden`
3. バイナリ扱い → `--text`（=`-a`相当）

例（図の主旨）：

```bash
rg --no-ignore 'pattern'
rg --hidden 'pattern'
rg --text 'pattern'
```

### 詳細解説

rgは“賢い”分、**デフォルトで除外される対象**があります。
「出ない」場合は、まず原因を切り分けます。

### Tips：実務の切り分け順（おすすめ）

1. 隠しファイルか？ → `--hidden`
2. ignoreか？ → `--no-ignore`（ただしノイズ・重さ増）
3. バイナリ判定か？ → `--text`（ログや生成物で必要になることあり）

---

## １４ チートシート（覚えるべき最小セット）

![rg14.rg（ipgrep）チートシート](/images/gamehub/rg14.rg（ipgrep）チートシート.jpg)

### 図の要旨（要点だけ再整理）

* 絞り込み：`-g`
* 文脈：`-C`
* ファイル名のみ：`-l`
* 固定文字列：`-F`
* 単語一致：`-w`
* 抽出：`-o`
* 高度正規表現：`--pcre2`
* 複数行：`-U`

### Tips：この8個だけで「体感」が変わる

最初の1週間は、次の使い分けだけで十分です。

* **探す**：`rg 'word'`
* **絞る**：`rg -g'*.ts' 'word'`
* **読む**：`rg -C 3 'word'`
* **抽出**：`rg -o 'regex' file`
* **外れ対策**：`--hidden` / `--no-ignore`

---

## １５　締め：インストールと今日からの習慣化

![rg15.grepより速く、findより手軽に](/images/gamehub/rg15.grepより速く、findより手軽に.jpg)

### 図の要旨

* メッセージ：grepより速く、findより手軽に
* インストール例：brew / choco / apt

### 詳細解説：代表的な導入

```bash
# macOS
brew install ripgrep

# Ubuntu / Debian
sudo apt update && sudo apt install -y ripgrep

# Windows（Chocolatey）
choco install ripgrep
```

### Tips：インストール後の確認と“標準化”

```bash
rg --version
rg --help | rg -n 'pcre2|hidden|no-ignore|glob|type'
```

---

# 追加Tips（“好きになる”ための実戦ネタ集）

## 1) 検索結果を見やすくする（lessと色）

```bash
rg --color=always 'pattern' | less -R
```

## 2) `.ripgreprc` で自分のデフォルトを作る（任意）

例：`~/.ripgreprc` に書いておくと、毎回オプションを打たなくて済みます。

```text
--smart-case
--hidden
--glob=!.venv/*
--glob=!node_modules/*
```

（※プロジェクト方針により `--hidden` は慎重に）

## 3) “置換”は安全第一（NULL区切り）

```bash
rg -l --null 'from' | xargs -0 sed -i 's/from/to/g'
```

## 4) VSCodeと相性が良い運用

* まずターミナルで `rg` で当たりを付ける
* その後、VSCodeの検索で絞り込み・置換・レビュー
  （rgは“探索”、エディタは“編集”に寄せると強いです）

