## Page 01. 表紙：The Digital Handshake（デジタルの握手）

![Re1.RESTAPI：デジタル世界の握手](/images/REST/Re1.RESTAPI：デジタル世界の握手.jpg)

### 図の要旨

APIは単なる通信手段ではなく、将来のビジネスを支える「デジタル資産」。
**Robust（堅牢）・Secure（安全）・for Developers（開発者に優しい）** が重要、という宣言です。

### 詳細解説（用語）

* **API**: Application Programming Interface。人間同士の「会話」ではなく、システム同士がやり取りするための「窓口」。
* **REST API**: Webの仕組み（HTTP）を使って、データ（リソース）を一貫した作法で扱うAPI設計スタイル。

### Tips（実務）

* 「動けばOK」で作ったAPIは、後から必ず辛くなります。
  例：エラーが全部200、URLが動詞だらけ、仕様が口伝、など → 運用で破綻しがち。

---

## Page 02. APIとは「契約」であり「システム間の対話」

![Re2.APIとは「契約」であり、システム間の「対話」である](/images/REST/Re2.APIとは「契約」であり、システム間の「対話」である.jpg)

### 図の要旨

RESTの基本はざっくり3つ：

1. **リソース指向**（名詞で設計）
2. **ステートレス**（状態を持ち回らない）
3. **HTTP標準の活用**（メソッド/ステータス/ヘッダなど）

### 詳細解説（用語）

* **契約（Contract）**: リクエスト形式、レスポンス形式、エラー形式、認証方式などを明文化し、双方が守る約束。
* **リソース（Resource）**: 「ユーザー」「注文」「商品」など、APIが扱う対象（名詞）。
* **ステートレス（Stateless）**: サーバが「前回のやり取り」を前提にしない。
  → 毎回必要な情報（トークン、パラメータ等）を渡す。
* **HTTP標準**: GET/POSTなどのメソッド、200/404などのステータス、Cache-Control等のヘッダ。

### Tips（実務）

* ステートレスにすると、**スケール（台数増）** がしやすいです。
  逆に「前回の状態がサーバに残ってる前提」だと、負荷分散や障害復旧が難しくなります。

---

## Page 03. リソース指向設計：URLは“名詞”で表す

![Re3.リソース設計指向：名刺で語り、動詞は捨てる](/images/REST/Re3.リソース設計指向：名刺で語り、動詞は捨てる.jpg)

### 図の要旨

URLは動詞ではなく名詞で。
例：`/users`、`/orders` のように「モノ」を表す。
動作はHTTPメソッド（GET/POST…）で表す。

### 詳細解説（用語）

* **エンドポイント**: APIのアクセス先URL（例：`/users`）。
* **コレクション vs 単体**

  * コレクション：`/users`（ユーザー集合）
  * 単体：`/users/{id}`（特定ユーザー）
* **よくあるアンチパターン**

  * `/getUser` のような動詞URL（HTTPメソッドと役割が二重化して混乱）

### Tips（実務）

* 命名のコツ（スライド下の指針）

  * **名詞で統一**
  * **複数形で統一**（`/users`、`/orders`）
  * **階層は浅めに**（深いネストは運用で辛い）
  * **kebab-case 推奨**（例：`/user-profiles`）
* 「操作」をどう表す？
  原則はリソース化します。
  例：`/orders/{id}/cancel` を作りたくなったら、
  `order-cancellations` というリソースにする案も検討（`POST /order-cancellations`）。

---

## Page 04. HTTPメソッド：動作はURLではなくメソッドで表現する

![Re4.HTTPメッソド：意図を伝える「動詞」の作法](/images/REST/Re4.HTTPメッソド：意図を伝える「動詞」の作法.jpg)

### 図の要旨

* **GET**: 取得
* **POST**: 新規作成
* **PUT**: 置き換え（全体更新）
* **PATCH**: 部分更新
* **DELETE**: 削除

### 詳細解説（用語）

* **Request Body**: POST/PUT/PATCHで送るデータ本体（JSONなど）。
* **Partial Update**: PATCHで「変更したい項目だけ」送る更新。
* **PUT vs PATCH**

  * PUT：送った内容が“完全な完成形”として扱われるイメージ
  * PATCH：差分だけ適用（ただし設計次第で難しくなる）

### Tips（実務）

* 「更新APIはPUTかPATCHか？」で迷ったら：

  * まずは**PUT（全体）** でシンプルにできないか検討
  * 部分更新が多く、項目数が大きい/競合が増えるならPATCH検討

---

## Page 05. 安全性（Safe）と冪等性（Idempotent）

![Re5.安全性と冪等性：信頼できる対話の条件](/images/REST/Re5.安全性と冪等性：信頼できる対話の条件.jpg)

### 図の要旨

* **Safe**: 状態を変えない（読取のみ）
* **Idempotent**: 同じリクエストを何回送っても結果が同じ（少なくとも“最終状態”が同じ）

### 詳細解説（用語）

* **GET/HEAD**: Safe & Idempotent（読むだけ）
* **PUT/DELETE**: 状態は変えるが Idempotent（同じ操作を繰り返しても最終状態は同じになりやすい）
* **POST**: 原則 Idempotent ではない（連打で作成が増える可能性）
* **リトライ（再送）**: ネットワークでは当たり前に起きる。だから冪等性が超重要。

### Tips（実務）

* POSTでも安全にしたい場合：

  * **Idempotency-Key**（一意キー）をヘッダで受け、サーバ側で二重作成を防止
  * 例：決済・注文確定など「二重実行が致命的」な操作は必須級

---

## Page 06. HTTPステータスコード：200固定はNG

![Re6.HTTPステータスコード：名家kなフィーバックを返す](/images/REST/Re6.HTTPステータスコード：明確なフィーバックを返す.jpg)

### 図の要旨

成功/失敗の意味をステータスで伝える。
「エラーだけど200」はクライアントが地獄を見る典型です。

### 詳細解説（用語）

* 成功系

  * **200 OK**: 取得や更新が成功
  * **201 Created**: 作成成功（Locationヘッダで作成先を返すことも）
  * **204 No Content**: 成功したが返す本文なし（DELETEや更新で便利）
* クライアント起因（4xx）

  * **400 Bad Request**: 形式や入力が不正
  * **401 Unauthorized**: 認証できない（ログイン/トークン不備）
  * **403 Forbidden**: 認証はできたが権限がない
  * **404 Not Found**: 存在しない
  * **429 Too Many Requests**: リクエスト回数制限超過
* サーバ起因（5xx）

  * **500 Internal Server Error**: サーバ側の想定外

### Tips（実務）

* ありがちな設計指針

  * バリデーション不正：400（どの項目がどうダメかは本文で）
  * 認証失敗：401、権限不足：403
  * 「存在しない」：404（ただし、セキュリティ要件でわざと404に寄せる場合も）

---

## Page 07. ページング・フィルタ・ソート

![Re7.ページネーションとフィルタリング](/images/REST/Re7.ページネーションとフィルタリング.jpg)

### 図の要旨

大量データは必ずページング。
方式は主に2つ：

* **Offset-based**（`offset`/`limit`）
* **Cursor-based**（`cursor`/`limit`）

### 詳細解説（用語）

* **クエリパラメータ**: `?limit=20&offset=40` のようにURL末尾で条件指定。
* **Offset方式の弱点**

  * 件数が増えるほど遅くなりやすい
  * 途中でデータが増減すると、ページがズレる（重複/欠落）
* **Cursor方式の強み**

  * 大規模で安定しやすい（「次の位置」をキーで持つ）
  * 時系列（created_at）などと相性が良い

### Tips（実務）

* まず小規模なら offset で開始 → 伸びたら cursor に移行でもOK
* ソートは `sort=-price` のように「-で降順」など**ルールを固定**すると親切です。

---

## Page 08. エラーハンドリング：機械にも人にも分かる形式

![Re8.エラーハンドリング：トラブル時の誠実さ](/images/REST/Re8.エラーハンドリング：トラブル時の誠実さ.jpg)

### 図の要旨

エラーはJSONで構造化して返す：

* `code`（機械向け）
* `message`（人向け）
* `details`（補足）
* `request_id`（ログ追跡用）

### 詳細解説（用語）

* **機械可読（Machine-readable）**: `code` を見てクライアントが分岐できる
* **相関ID（Correlation ID / request_id）**: 障害解析の生命線。ログで追える。
* **情報漏洩**: スタックトレースや内部テーブル名をそのまま返さない（攻撃の手掛かりになる）

### Tips（実務）

* 例（考え方）

  * `code`: `VALIDATION_ERROR`, `RESOURCE_NOT_FOUND`, `RATE_LIMITED` など固定語彙
  * `details`: `[{ field: "email", reason: "invalid_format" }]` のようにUI表示にも使える形が便利
* 監視・運用では `request_id` を必ずログに出し、問い合わせ対応を短縮できます。

---

## Page 09. セキュリティ：HTTPS・認証/認可・レート制限

![Re9.セキュリティ：強固な門番とマナー](/images/REST/Re9.セキュリティ：強固な門番とマナー.jpg)

### 図の要旨

* **HTTPS必須**
* **OAuth2 / Bearer Token** などの標準を利用
* **認証（AuthN）と認可（AuthZ）を分離**
* **Rate Limit** と **429** を活用

### 詳細解説（用語）

* **認証（Authentication）**: あなたは誰？
* **認可（Authorization）**: あなたは何ができる？
* **Bearer Token**: `Authorization: Bearer <token>` で送るトークン
* **レート制限**: 連打/攻撃/誤作動から守る仕組み
* **429 Too Many Requests**: 制限超過の定番ステータス

### Tips（実務）

* レート制限は「全部同じ」ではなく、用途別に考える
  例：検索APIは緩め、更新/決済系は厳しめ、など
* 返すと親切なヘッダ例

  * `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After`

---

## Page 10. 情報漏洩を防ぐ：レスポンスは“許可リスト”で組み立てる

![Re10.レスポンスの保護：沈黙すべき情報](/images/REST/Re10.レスポンスの保護：沈黙すべき情報.jpg)

### 図の要旨

DBや内部オブジェクトをそのまま返さない。
**出して良い項目だけを明示（Allowlist）** して返す。

### 詳細解説（用語）

* **サニタイズ（Sanitize）**: 不要/危険な情報を除去・加工する
* **Allowlist**: 「これだけ返して良い」を固定（推奨）
* **Denylist**: 「これを返しちゃダメ」を列挙（漏れが出やすい）
* **セキュリティヘッダ**

  * **HSTS**: HTTPS強制
  * **CSP**: スクリプト読み込み制御（XSS対策）

### Tips（実務）

* APIのレスポンス用DTO（View Model）を作ると事故が減ります
  例：DBには `password_hash`, `internal_flag` があるが、APIは返さない。

---

## Page 11. バージョニング：破壊的変更をコントロールする

![Re11.バージョニング：進化と互換性の両立](/images/REST/Re11.バージョニング：進化と互換性の両立.jpg)

### 図の要旨

`/v1/...` と `/v2/...` のようにバージョンを持ち、互換性を守る。
後方互換の追加なら、基本はv1のままでも良い（方針次第）。

### 詳細解説（用語）

* **破壊的変更（Breaking Change）**: 既存クライアントが動かなくなる変更
  例：必須項目追加、型変更、意味変更、削除など
* **後方互換（Backward compatible）**: 既存が壊れない変更
  例：任意項目追加、レスポンスに新フィールド追加（クライアントが無視できる前提）

### Tips（実務）

* APIは「消す」のが一番コスト高。消さずに段階移行できる設計が強いです。
* 廃止予定はドキュメントに明記し、レスポンスヘッダ等で通知する運用も有効。

---

## Page 12. パフォーマンス：キャッシュ・ETag・部分レスポンス

![Re12.パフォーマンス：対話のテンポを落とさない](/images/REST/Re12.パフォーマンス：対話のテンポを落とさない.jpg)

### 図の要旨

速さと帯域は“設計”で効きます。

* **キャッシュ**
* **ETag（変更検知）**
* **Partial Response（必要な項目だけ返す）**

### 詳細解説（用語）

* **Cache-Control**: キャッシュ指示（例：`max-age=60`）
* **ETag**: コンテンツの版（ハッシュのようなもの）
* **If-None-Match**: ETagが変わってなければ 304 を返す仕組み
* **fields**: `?fields=id,name` のように必要項目だけ返す設計

### Tips（実務）

* 一覧APIは特に効果大

  * 一覧は軽く（必要最小限）、詳細は別APIで取る（`/users` と `/users/{id}`）
* 「まず遅くならない設計」にしておくと、後から地獄のチューニングをしなくて済みます。

---

## Page 13. ドキュメントと開発者体験（DX）

![Re13.ドキュメントとDX：APIのユーザーインターフェース](/images/REST/Re13.ドキュメントとDX：APIのユーザーインターフェース.jpg)

### 図の要旨

APIは「使われて価値が出る」ので、ドキュメントも製品の一部。
**OpenAPI（Swagger）** で仕様を機械可読にするのが近道。

### 詳細解説（用語）

* **OpenAPI**: API仕様をYAML/JSONで表現する標準
* **Design-first**: 先に仕様（OpenAPI）→ 実装生成/実装の順（ブレが減る）
* **Try it out**: ブラウザで試せるUI（Swagger UI等）

### Tips（実務）

* ドキュメントに最低限欲しいもの

  * 代表的ユースケース（例：作成→取得→更新→削除の流れ）
  * エラー例（code/message/details/request_id）
  * 認証方法（curl例）
  * レート制限の説明

---

## Page 14. 最終チェックリスト（品質の観点）

![Re14.チェックリスト：優れたAPIの条件](/images/REST/Re14.チェックリスト：優れたAPIの条件.jpg)

### 図の要旨

チェック観点を6カテゴリに整理：

* Predictability（予測可能）
* Correctness（正確）
* Security（安全）
* Kindness（親切）
* Efficiency（効率）
* Usability（使いやすさ）

### Tips（実務）

* 迷ったらこの質問でセルフレビュー

  * 「これは初見の人が間違えにくいか？」
  * 「リトライしても壊れないか？」
  * 「ログ追跡できるか？」
  * 「将来の変更に耐えられるか？」

---

## Page 15. まとめ：未来への礎

![Re15.未来への礎](/images/REST/Re15.未来への礎.jpg)

### 図の要旨

良いREST APIは“技術作業”ではなく、長期で価値を生む“資産づくり”。

### Tips（実務）

* 最後のメッセージ「Build Robust / Secure / for Developers」を、設計レビューの合言葉にするとブレません。

---

# 付録：初心者向け「REST APIでここだけは押さえる」入力リスト（NotebookLM用）

* RESTの考え方（リソース指向、ステートレス、HTTP標準活用）
* URL設計（名詞、複数形、階層、命名規則）
* HTTPメソッド（GET/POST/PUT/PATCH/DELETE、使い分け）
* 安全性（Safe）と冪等性（Idempotent）、リトライ設計
* ステータスコード（2xx/4xx/5xx、よく使うもの）
* リクエストの基本（パスパラメータ、クエリパラメータ、ヘッダ、ボディ）
* レスポンスの基本（JSON、スキーマ、フィールド設計）
* エラー設計（code/message/details/request_id、情報漏洩防止）
* 認証/認可（Bearer Token、OAuth2の概要、権限設計）
* 入力バリデーション（400の出し方、フィールド単位のエラー表現）
* ページング（offset vs cursor）・フィルタ・ソート
* セキュリティ基本（HTTPS、レート制限、429、ログ、マスキング）
* バージョニング（破壊的変更、後方互換、廃止運用）
* パフォーマンス（キャッシュ、ETag、一覧と詳細の分離、fields）
* ドキュメント（OpenAPI、例、利用シナリオ、Try it out）
* 運用観点（監視、ログ相関ID、エラー率、SLO/SLIの入門）
* テスト観点（契約テスト、正常系/異常系、境界値、リトライ系）
* クライアント観点（タイムアウト、リトライ、バックオフ、サーキットブレーカ入門）
* ありがちなアンチパターン集（200固定、動詞URL、内部情報露出、曖昧な仕様）
