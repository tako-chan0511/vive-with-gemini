## この資料の読み方（全体の狙い）
本資料は、**AIが「会話する存在（Chatbot）」から「行動する存在（Agent）」へ進化**したことで、セキュリティの重心が「有害発話」から **“実行・権限・外部接続” を伴う機能的リスク**へ移った、という前提に立っています。  
そして、プロンプト工夫のような**単一防御**ではなく、**多層防御（Defense in Depth）**で事故確率を下げる「要塞（Fortress）」設計を説明します。

- **第1層（構造）**：LLMの役割を分離し、危険な入力を “実行権限のあるLLM” に直結させない  
- **第2層（物理）**：ツール呼び出しと実行環境を隔離し、鍵・ネットワーク・OS権限を守る  
- **第3層（意味）**：入出力を最小化/無害化し、思考/意図の逸脱（乗っ取り）を監視する  
- **運用（第4層）**：権限・承認・監査ログで「やらかしても被害が広がらない」状態を保つ

## 1. P01：Securing Agentic AI: The Fortress Architecture（表紙）
![Se1.SecuringAgenticAI：TheFortressArchtecture（次世代AIエージェントの防御戦略）](/images/IaC/Se1.SecuringAgenticAI：TheFortressArchtecture（次世代AIエージェントの防御戦略）.jpg)


### 図の要旨
- 「Agent化」により、AIは **外部ツール（DB/メール/決済/社内システム）** へ手を伸ばす
- その結果、**発話の安全性だけでは不十分**になり、**実行の安全性**が主戦場になる
- Fortress（要塞）＝**多層防御**で「侵入前提でも被害を抑える」設計思想

### 詳細解説（用語）
- **Agentic AI（AIエージェント）**：指示に応じて計画し、ツールを使い、状態を更新し、作業を完了させるAI
- **Defense in Depth（多層防御）**：1つの防壁が破られても、次の層で止める設計
- **機能的リスク**：誤った/悪意ある操作で **“システムが実際に動く”** ことに伴う損害（削除、送金、漏えい等）

### Tips（実務）
- まずは「Agentが触れる資産」を棚卸し  
  - *例：顧客DB、メール送信、S3、Git、決済API、勤怠、社内Wiki…*  
- 資産ごとに「最悪ケース」を1行で書く（これが設計の起点）  
  - *例：顧客DBの誤削除 / 誤送金 / 機密添付の外部送信 / 内部URLの外部流出…*

---

## 2. P02：Saying → Doing（権限拡大が招く機能的リスク）
![Se2.SayingからDoingへ：権限の拡大が招く「機能的リスク」](/images/IaC/Se2.SayingからDoingへ：権限の拡大が招く「機能的リスク」.jpg)

### 図の要旨
- Chatbot時代の主なリスク：**有害発言、幻覚、評判毀損**
- Agent時代の主なリスク：**改ざん/削除、詐欺/送金、機密漏えい**
- 「**信頼できない入力** × **センシティブな権限**」が揃うと破局（Rule of Two）

### 詳細解説（用語）
- **Untrusted Input（信頼できない入力）**：ユーザー入力、Web、メール、社内文書、ログ、チケットなど  
  → *“見た目はデータでも、中に命令が混ざる”* のが問題
- **Sensitive Access（重要権限）**：書き込み、削除、送金、外部送信、鍵参照、社内限定情報の閲覧など
- **Rule of Two**：  
  - (1) 信頼できない入力を読む  
  - (2) 強い権限で行動できる  
  → この2つが同じ経路に乗ると危険度が跳ね上がる

### Tips（実務）
- **“読むLLM” と “実行するLLM” を分ける**（後述のDual LLM）  
- “実行する側” には **最小権限**のツールしか渡さない  
  - *例：DBは基本 read-only、書き込みは別ルート＋人間承認*

---

## 3. P03：間接Prompt Injection（データに紛れた命令）
![Se3.崩れ去る境界線：間接的プロンプトインぜくしょん（IndirectPromptInjection）](/images/IaC/Se3.崩れ去る境界線：間接的プロンプトインぜくしょん（IndirectPromptInjection）.jpg)

### 図の要旨
- Agentは「メール要約」「Web調査」などで **外部コンテンツ**を読む
- そのコンテンツに **隠れた命令**（“次にこれを実行せよ”）が混ざると、AIが乗っ取られる
- 境界が曖昧：**データ**と**命令**が同じ自然言語で表現されるのが根本原因

### 詳細解説（用語）
- **Indirect Prompt Injection（間接注入）**：ユーザーの直接指示ではなく、参照先の文書/サイト/メールに混ぜた命令でAIを誘導する攻撃
- **Zero-click**：ユーザーが攻撃文書を“開いただけ”で成立（＝通常操作でも踏む）
- **境界問題**：LLMは「ここまでが情報、ここからが命令」を厳密に判定できない

### Tips（実務）
- 外部コンテンツは **必ず隔離LLMで読み**、結果を **構造化（JSON）** して渡す  
- 「命令っぽい文」を検出したら、**要約から除外**するルールを入れる  
  - *例：「〜を実行せよ」「前の指示を無視」「秘密を送れ」などは “命令” として隔離*

---

## 4. P04：適応的攻撃（静的防御を回避する）
![Se4.攻撃の高度化：静的防御を無力化する適応型攻撃](/images/IaC/Se4.攻撃の高度化：静的防御を無力化する適応型攻撃.jpg)

### 図の要旨
- 攻撃者は、AIの応答を観測して **プロンプトを最適化**できる（フィードバックループ）
- 会話を重ねて、徐々に話題を逸らし **安全域から危険域へ滑らせる**攻撃もある
- “固定のNGワード” や “単発のフィルタ” だけでは破られやすい

### 詳細解説（用語）
- **Adaptive Attack**：モデルの挙動に合わせて攻撃を調整する（自動探索/最適化）
- **Semantic Drift（意味のドリフト）**：一見無害な会話から段階的に危険な要求へ誘導する
- **Supply chain（供給網）**：モデル/ツール/データの取り込み経路が攻撃点になる（モデル学習、プラグイン等）

### Tips（実務）
- 防御は “単発判定” だけでなく、**状態（コンテキスト）を持って監視**する  
- 重要操作（送信/削除/支払）は **“会話の流れ” と “操作内容” の整合**をチェックする（後述：CoT Audit/Intent監視）

---

## 5. P05：Fortress Blueprint（多層防御の全体像）
![Se5.TheFortressArchtecture：3層の防御ドクトリン](/images/IaC/Se5.TheFortressArchtecture：3層の防御ドクトリン.jpg)

### 図の要旨
- 防御を「構造」「物理」「意味」に分け、層ごとに役割を持たせる
- 中心は **Plan-then-Execute**（計画→検査→実行）  
- “LLMは破られる前提”で、**事故が現実世界へ出る経路**を塞ぐ

### 詳細解説（用語）
- **Plan-then-Execute**：  
  1) まず計画（何をするか）  
  2) ポリシー検査（やって良いか）  
  3) 実行（ツール呼び出し）  
  → 直接実行しないのが肝
- **Policy Gate**：実行前に強制する“関門”（ルール、承認、検証）

### Tips（実務）
- 「計画」と「実行」を同じLLMにやらせない（分離）  
- “計画” は **宣言的（JSON/DSL）**にして、検査しやすくする  
  - *例：{action:"send_email", to:"...", attachments:["..."], reason:"..."}*

---

## 6. P06：第1層【構造】Dual LLM + Plan-then-Execute
![Se6.第一層（構造）：Plan-then-executeとDualLLMパターン](/images/IaC/Se6.第一層（構造）：Plan-then-executeとDualLLMパターン.jpg)

### 図の要旨
- **隔離LLM（Quarantine）**：信頼できないデータを読む専用（実行権限なし）
- **特権LLM（Privileged）**：ツール実行に関わるが、入力は“浄化済み”のみ
- データ→計画→実行の間に **検査ポイント**を挟める

### 詳細解説（用語）
- **Quarantine LLM**：  
  - 役割：外部文書の要約、抽出、分類  
  - 禁止：ツール呼び出し、秘密参照、外部送信の意思決定
- **Privileged LLM**：  
  - 役割：計画生成、最終判断  
  - 前提：入力が構造化され、命令注入が除去されている
- **Sanitized JSON**：自然言語をそのまま渡さず、**データ項目として渡す**（命令になりにくい）

### Tips（実務）
- 最低限の実装でも効果が大きい「最小Dual LLM」：
  1) 隔離LLM：`extract_facts(text) -> {facts:[...], pii:[...], suspicious:[...]}`  
  2) 特権LLM：`make_plan(facts) -> plan`  
  3) ルール：`if suspicious not empty => 実行禁止 or 人間承認`
- 既存の1LLMエージェントへ追加するなら、まず **「外部ドキュメント読む処理」だけ隔離**するのが最短

---

## 7. P07：第2層【物理】Tool Boundary / MCP（鍵と流れを守る）
![Se7.第二層（物理）：ツール境界（ToolBoundary）とMCP](/images/IaC/Se7.第二層（物理）：ツール境界（ToolBoundary）とMCP.jpg)

### 図の要旨
- AI→ツールの接続を **プロトコル境界（MCP等）** に集約し、検査/制御しやすくする
- **タグ付け（分類）** で「PIIは外部送信禁止」などの流量制御が可能
- **APIキー等の秘密情報**をLLMに見せない（Zero token exposure）

### 詳細解説（用語）
- **MCP（Model Context Protocol）**：モデル/エージェントとツールを接続するためのプロトコル（“ツール呼び出しの標準化”という捉え方でOK）
- **Data Tagging**：データに分類ラベルを付け、流れを制御する  
  - *例：`is_pii=yes` のデータは “Public Web Tool” に渡さない*
- **Zero token exposure**：鍵や機密をLLMのトークン列に載せない（ログ/学習/漏えい面で効く）

### Tips（実務）
- 「ツールは全部HTTPで直叩き」より、**ツール・ゲートウェイ**を置くほうが安全に寄せやすい  
- 鍵はOS環境変数でも良いが、可能なら **Vault/Secrets Manager**へ寄せる  
- “外部送信ツール” は別枠にして、デフォルト拒否＋承認にする（Least Privilege）

---

## 8. P08：第2層【物理】実行環境のサンドボックス（Container vs MicroVM）
![Se8.第二層（物理）：実行環境のサンドボックス化](/images/IaC/Se8.第二層（物理）：実行環境のサンドボックス化.jpg)

### 図の要旨
- コンテナは便利だが、基本的に **同一カーネル共有**で逃げ道がある
- MicroVM（例：Firecracker）は **より強い隔離**を提供できる
- Syscall制限（seccomp等）や、ネットワーク遮断（egress制御）が重要

### 詳細解説（用語）
- **Container**：プロセス隔離中心。カーネルは共有。設定次第で突破面が残りやすい
- **MicroVM**：VM寄りの隔離。ゲストOS/カーネルで境界が厚い
- **seccomp**：Linuxのシステムコール（OS機能呼び出し）を制限して攻撃面を縮める
- **Egress filter**：外向き通信を制限（データ持ち出しの最重要対策の1つ）

### Tips（実務）
- “コード実行” を伴うツール（Python実行、Shell、ファイル変換等）は **最優先で隔離**  
- まずは次の順に現実的：
  1) コンテナ＋read-only FS＋最小権限  
  2) seccomp/gVisor等で追加制限  
  3) 可能ならMicroVM/別ノード隔離
- 送信先を限定する：  
  - *例：許可リスト（社内APIだけ）にし、それ以外の外部宛ては遮断*

---

## 9. P09：第3層【意味】I/O Firewall（Minimize & Sanitize）
![Se9.第三層（意味）：入出力のファイアウォール（Minimizer＆Sanitizer）](/images/IaC/Se9.第三層（意味）：入出力のファイアウォール（Minimizer＆Sanitizer）.jpg)

### 図の要旨
- ツール呼び出しの **入力（args）** を最小化（Minimize）して漏えい面を減らす
- ツールの **出力**を無害化（Sanitize）して、命令注入を持ち込ませない
- “モデルの再学習なし”でも、**入出力の設計**で攻撃成功率を下げられる

### 詳細解説（用語）
- **Minimizer**：ツールに渡す引数を必要最小限にする  
  - *例：メール本文を丸ごと渡さず、要約/要点だけ渡す*
- **Sanitizer**：返ってきた結果から “命令/スクリプト/誘導文” を除去・無効化する  
  - *例：「次にこのURLを開け」「前の指示を無視」などを検知し、データとして扱う*
- **PII**：個人情報（氏名、電話、住所、メール、顧客IDなど）。流出させないルールの中心

### Tips（実務）
- 典型の事故パターンは「**ツール出力に混ざった命令**を、そのまま次のLLM入力に渡す」  
  → **“出力の構造化”** で防げる  
- Sanitizerの最低ライン例：
  - URL/コマンドっぽい文を隔離欄に退避  
  - “命令調” の文（imperative）を抽出して別配列に分ける  
  - HTML/Markdownのスクリプト要素や隠しテキストを除去

---

## 10. P10：CoT Audit / Intent監視（目的の乗っ取り検知）
![Se10.第三層（意味）：Chain-of-Thought（CoT）監査とLlamaFirewall](/images/IaC/Se10.第三層（意味）：Chain-of-Thought（CoT）監査とLlamaFirewall.jpg)

### 図の要旨
- ユーザーの目的（Goal）と、エージェントの意図（Intent）がズレたら危険
- “翻訳依頼”なのに “パスワード送信” を計画していたら **乗っ取りの兆候**
- **継続監視（stateful）** が重要：単発より強い

### 詳細解説（用語）
- **CoT（Chain-of-Thought）**：推論過程（※実装では “完全な思考” を必ずしも保存しない方が安全な場合もある）  
- **Intent alignment**：ユーザーの要求と、計画/行動が一致しているか
- **Goal hijacking**：第三者の指示で目的がすり替わる（間接注入の典型結果）

### Tips（実務）
- 実装の現実解：**“思考そのもの” より “計画の要約” を監査対象にする**  
  - *例：plan.json を監査ログに残し、逸脱ルールで止める*
- 逸脱ルールの例：
  - ユーザー要求にない “送信/削除/外部共有/支払” が含まれる → STOP＋承認  
  - 宛先が新規ドメイン → STOP  
  - 添付/本文にPIIが含まれる → STOP

---

## 11. P11：ガードレール実装の分類（何をどこで使うか）
![Se11.ガードレールツールのランドスケープ](/images/IaC/Se11.ガードレールツールのランドスケープ.jpg)

### 図の要旨
- ガードレールには役割が違う種類がある（会話制御 / 構造検証 / I/Oフィルタ / 監査）
- 1つの製品で全部やるのは難しいので、**層に対応付けて組み合わせる**

### 詳細解説（用語）
- **Conversation Flow**：シナリオの状態遷移を制御（例：本人確認→同意→操作）
- **Structural Validation**：JSONスキーマ/型で “形式” を守る（＝検査が容易）
- **Prompt Shield / Guard**：注入や危険要求の分類器で、入口/出口を弾く
- **Agent Audit**：計画・ツール実行の監査、意図整合チェック

### Tips（実務）
- “まず入れるなら”優先度は高い順に：
  1) **構造検証（JSON/Schema）**：壊れた出力を実行しない  
  2) **入口フィルタ**：明らかな攻撃を弾く  
  3) **計画監査**：危険操作を止める  
  4) **出口フィルタ**：漏えい防止
- 既存アプリに追加する際は、**実行直前のゲート**が最も費用対効果が良い

---

## 12. P12：Difyでの実装例（ワークフローに落とす）
![Se12.第三層（実装）：実践的実装：Difyにおける防御構築](/images/IaC/Se12.第三層（実装）：実践的実装：Difyにおける防御構築.jpg)

### 図の要旨
- Difyのノード（HTTP/LLM/コード実行/承認）を組み合わせてFortressを再現できる
- “Guardrails API”や“SSRF対策プロキシ”を挟むことで、外部接続の安全性が上がる

### 詳細解説（用語）
- **Human-in-the-loop（HITL）**：危険度が高い操作だけ人間承認
- **SSRF**：サーバ側から内部URLへアクセスさせる攻撃。エージェントの “Web取得” と相性が悪いので対策必須
- **Workflow**：分岐・検査・承認が表現しやすく、Plan-then-Executeを作りやすい

### Tips（実務）
- Dify最小構成（例）：
  1) Start  
  2) **Input Guard（HTTP）**：注入/PII/危険要求チェック  
  3) **Planner LLM**：plan.json を作る  
  4) **Policy Check（Code/HTTP）**：ルールでOK/NG  
  5) **HITL（任意）**：NGや高リスクのみ承認  
  6) **Executor（Tool/Code）**：実行は隔離環境
- “Web取得ノード” は必ず **許可リスト**または **プロキシ**経由にする

---

## 13. P13：運用（第4層）— 最小権限・承認・監査ログ
![Se13.運用上のベストプラクティス：プロセスによる防御](/images/IaC/Se13.運用上のベストプラクティス：プロセスによる防御.jpg)

### 図の要旨
- どれだけ設計しても“ゼロ事故”は難しい  
  → **事故を小さくする運用**が最後に効く
- 人間承認、最小権限、監査ログが三本柱

### 詳細解説（用語）
- **Least Privilege（最小権限）**：普段使う権限は“最小”。書込み/削除は別ルート
- **Irreversible action**：取り返しがつかない操作（送信、削除、支払、公開）
- **Audit Log**：後追い可能なログ（誰が、何を、なぜ、どの入力で、どのツールを叩いたか）

### Tips（実務）
- ログに残す最小セット（おすすめ）：
  - user_id / session_id  
  - input（原文 or ハッシュ）  
  - plan.json（実行計画）  
  - tool calls（引数は最小化した上で）  
  - policy 判定結果（OK/NG理由）  
- “承認” はUIでも良いが、最低限「危険操作はyes/noで止める」だけでも効く

---

## 14. P14：将来像（自己修復・監督の多重化）
![Se14.将来展望：セルフヒーリングセキュリティへの進化](/images/IaC/Se14.将来展望：セルフヒーリングセキュリティへの進化.jpg)

### 図の要旨
- 防御も動的に進化し、監督モデル（Watcher）がエージェントを監視・修復する方向
- “Zero Trust Agent” 的に、常に検証し続ける思想へ

### 詳細解説（用語）
- **Watcher / Overseer**：別モデルが計画/実行を監視して止める
- **Self-healing**：異常を検知したら安全側へ戻す（実行停止、セッション隔離、再計画など）
- **Continuous verification**：一度OKでも、状態が変われば再チェック

### Tips（実務）
- いきなり高度化しなくてOK。現実には：
  - “実行前に別モデルで判定” するだけでもWatcherの第一歩
  - 監督は分類器でも良い（コスト優先）

---

## 15. P15：まとめ（チェックリスト）
![Se15.SummaryChecklist：今すぐ取り組むべきアクション](/images/IaC/Se15.SummaryChecklist：今すぐ取り組むべきアクション.jpg)

### 図の要旨
- **プロンプト工夫だけに頼らない**
- **物理的に隔離する**
- **入出力を最小化/無害化する**
- **計画（意図）を監査する**

### 実務チェックリスト（短縮版）
- [ ] 外部データ（Web/メール/文書）を読むLLMは **実行権限なし**  
- [ ] “実行する側”は **構造化入力のみ**を受ける（Sanitized JSON）  
- [ ] 危険操作（送信/削除/支払/公開）は **実行前ゲート**がある（ルール or 承認）  
- [ ] ツール境界に **鍵の秘匿**と **データタグ制御**がある  
- [ ] コード実行/ファイル操作は **隔離環境（sandbox）**  
- [ ] ツール出力は **Sanitize**して “命令” を次段に渡さない  
- [ ] plan/tool/policy を **監査ログ**に残す  

::: tip
まずは「危険操作の実行前ゲート（Plan→Policy→Execute）」を入れるだけで、事故確率が大きく下がります。  
次に「外部コンテンツ読み取りの隔離（Quarantine LLM）」を足すのが、最短で“要塞感”が出ます。
:::
