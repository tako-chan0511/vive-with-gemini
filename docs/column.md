# AI時代のエンジニア進化論：Viveコーディングが示す未来

### はじめに：AIは「仕事を奪う脅威」ではなく「思考を加速させる仲間」である

Viveコーディングとは、AIとの協業によって、私たちエンジニアの働き方そのものを進化させる、新しい開発スタイルです。それは、アジャイル開発の各フェーズにおいて、人間とAIの役割を再定義し、開発プロセス全体を加速させます。

以下の表は、その具体的な協業モデルを示しています。

| アジャイルフェーズ | 目的 | 相棒（Gemini）の役割 | あなたの役割（人間） |
| :--- | :--- | :--- | :--- |
| **1. 構想・計画**<br>(Inception Deck) | **Whyの定義**<br>（なぜ作るのか） | **発想の触媒**<br>・アイデアの壁打ち<br>・ペルソナ案のリストアップ | **最終意思決定者**<br>・プロジェクトのビジョン提供<br>・最終的なWhyの決定 |
| **2. 要求定義**<br>(Product Backlog) | **Whatの定義**<br>（何を作るのか） | **構造化の支援者**<br>・PBIのリストアップ<br>・ユーザーストーリー形式への変換 | **価値の優先順-位付け担当**<br>・ビジネス価値の判断<br>・PBIの優先順位決定 |
| **3. 洗練・設計**<br>(Backlog Refinement) | **Howの定義**<br>（どうやって作るか） | **技術的選択肢の提案者**<br>・アーキテクチャ案の提示<br>・API設計、DBスキーマの提案 | **ROIの評価者**<br>・各技術案のコストを評価<br>・保守性や拡張性を判断 |
| **4. 実装・価値提供**<br>(TDD/Sprint) | **Doの実践**<br>（実際に作る） | **高速コーダー**<br>・テストをパスするコード生成<br>・リファクタリング案の提示 | **TDDの指揮者＆品質保証担当**<br>・**失敗するテスト（問い）を書く**<br>・AIのコードをレビュー・統合 |

<br>

私たちの現場には、変化に対する漠然とした不安が常に存在します。「AIに仕事が奪われる」という言葉を、あなたも一度は耳にしたことがあるでしょう。

しかし、Viveコーディングの本質は、人間の仕事を奪うことではありません。それは、私たちが日々直面している「創造性のない単純作業」や「変化への恐怖」から私たちを解放し、人間が本来やるべき<strong>「なぜ作るのかを問い、どう作るかを意思決定する」</strong>という、創造的な仕事に集中させてくれる強力なシフトレバーなのです。<strong>それは、私たちを「指示待ちの作業者」から「自ら仮説を立て、まず試す実験者」へと変える、新しい時代の働き方でもあります。</strong>

このコラムでは、3つの異なる役割を持つエンジニアの方々が、どのようにしてViveコーディングを自らの力に変えていけるか、その具体的な道筋を示します。

---

### 第1章：旧来型のエンジニアの方へ 〜「変えられない」から「"安全に"変えられる」へ〜

「この仕様は変えてはいけない」「前例がないから承認できない」
その言葉の裏にあるのは、<strong>「変更がシステムを壊すことへの恐怖」</strong>ではないでしょうか。その気持ちは、複雑な既存システムを守り抜いてきた方々だからこそ抱く、プロフェッショナルとして当然の感覚です。

Viveコーディングは、その恐怖に「精神論」ではなく<strong>「技術的な安全装置」</strong>で応えます。

1.  **AIによる「テストという名の保険」の自動生成:**
    「このレガシーコード、テストがないから怖くて触れない…」
    その状況こそ、AIの出番です。このサイトのデモで実証しているように、AIは既存のコードを変更する前に、その現状の振る舞いを保証する<strong>「安全ネット」としてのテストコードを瞬時に生成</strong>します。これにより、「もし変更が何かを壊しても、即座に検知できる」という絶大な心理的安全性が手に入ります。

2.  **変化を楽しむ「TDDサイクル」への招待:**
    仕様変更は、もはや「悪」ではありません。安全ネットがあれば、それは「管理された改善活動」に変わります。
    **「新しい仕様をテストコードとして記述し、AIに『このテストをパスさせて』と依頼する」**。このTDDサイクルこそ、変化を恐れない開発の心臓部です。AIはコーディング作業を劇的に短縮し、人間は「どんなテストを書くべきか」という、より上流の設計に集中できます。

**【この章のメッセージ】**
Viveコーディングがもたらすのは、無謀な破壊的変更ではありません。**鉄壁の安全装置をAIの力で瞬時に用意することで、変化をコストではなく、価値向上のチャンスとして歓迎できる文化**への第一歩なのです。

---

### 第2章：アプリケーション運用保守の方へ 〜「"お守り"から"価値創造の主役"へ」〜

長年稼働しているシステムの「お守り」。ドキュメントのない秘伝のコード、深夜の障害対応、そして「触らぬ神に祟りなし」という不文律…。その苦労は、計り知れません。
しかし、その困難な状況こそ、AIとの協業が最も輝く舞台です。Viveコーディングは、その受動的な保守業務を、能動的な価値創造活動へと劇的に転換させます。

#### **【具体例：COBOL資産のモダナイゼーションにおけるVive with Geminiの手順】**

これは、単なる「作り直し」ではなく、AIとの対話を通じて**既存の資産（ビジネスロジック）を正確に抽出し、安全に移植する**プロセスです。

**フェーズ0：【分析・分解】AIによるリバースエンジニアリング**

このフェーズが最も重要です。AIを「COBOL解析の専門家」として活用し、ブラックボックス化した既存システムの仕様を可視化します。

1.  **COBOLコードの解読と仕様抽出:**
    * **私 → Gemini:** 「このCOBOLプログラムの塊を渡すから、データ部（DATA DIVISION）と手続き部（PROCEDURE DIVISION）の役割を分析して。特に、この部分のビジネスロジックを、日本語の箇条書きで分かりやすく説明してくれないか？」
    * **Geminiの役割:** 難解なCOBOLコードを読み解き、自然言語の「仕様書」に変換する。

2.  **データ構造のTypeScript化:**
    * **私 → Gemini:** 「これがCOBOLのデータ定義体（COPY句）だ。これを元に、Vue3で使うためのTypeScriptの`interface`を生成してほしい。」
    * **Geminiの役割:** レガシーなデータ構造を、最新の型定義に変換する。

**フェーズ1：【設計・骨格構築】AIとのアーキテクチャ設計**

フェーズ0で可視化した仕様を元に、新しいシステムの土台を築きます。

1.  **アーキテクチャの壁打ち:**
    * **私 → Gemini:** 「抽出したビジネスロジックを元に、サーバーレスなバックエンド（Vercel Functions）を作りたい。データベースはどういう構成がいいか、Pros/Consを比較して提案してほしい。」
    * **Geminiの役割:** 最新のクラウド技術に基づいた、最適なアーキテクチャの選択肢を提示する。

2.  **APIの設計とモック作成:**
    * **私 → Gemini:** 「先ほど作成したTypeScriptの`interface`を元に、CRUD操作を行うためのREST APIのエンドポイントを設計して。まずはダミーデータを返すモック関数をVercel Functionsで作成してほしい。」
    * **Geminiの役割:** APIの設計と、フロントエンド開発を先行させるためのモックサーバーを迅速に構築する。

**フェーズ2：【実装・移植】TDDによる漸進的リプレース**

ここからが、AIとのペアプログラミング「バイブコーディング」の本番です。

1.  **振る舞いを保証するテストの作成:**
    * **私 → Gemini:** 「フェーズ0で抽出したCOBOLの仕様（日本語の箇条書き）を渡す。この仕様を満たしているかを確認するためのテストケースを、Vitestで網羅的に作成してほしい。」
    * **Geminiの役割:** 既存システムの振る舞いを保証する「動く仕様書」としてのテストコードを生成する。

2.  **テスト駆動でのロジック移植:**
    * **私 → Gemini:** 「この失敗するテスト（RED）をパスさせるための、TypeScriptのビジネスロジックを実装してほしい。参考として、元のCOBOLコードも渡しておく。」
    * **Geminiの役割:** テストという明確なゴールに向かって、COBOLのロジックをTypeScriptに正確に翻訳・実装する（GREEN）。

#### **Pros/Cons（利点と欠点）**

| Pros（利点） | Cons（欠点・リスク） |
| :--- | :--- |
| **1. 圧倒的な解析速度**<br>人間が数週間かけて行うCOBOLのコード解析と仕様理解の時間を、AIが数時間〜数日に劇的に短縮する。これが最大のメリット。 | **1. AIのCOBOL知識の限界**<br>AIは一般的なCOBOLには強いが、特定のベンダー拡張や、極度に複雑なビジネスロジックの解釈を間違える可能性がある。**人間の最終レビューは不可欠。** |
| **2. 「動く仕様書」の自動生成**<br>AIが生成したテストコードが、そのまま新しいシステムの「振る舞いを保証する仕様書」となり、ドキュメント不在問題を解決する。 | **2. セキュリティと機密情報**<br>既存システムのビジネスロジック（企業の重要資産）を外部のAIに渡すことのセキュリティリスク。企業のポリシーに準拠したAIの選定や、情報の抽象化が必要。 |
| **3. 技術的負債の返済とスキルシフト**<br>開発者は、AIのサポートを受けながら、レガシー技術の解読と最新技術での再実装を同時に体験でき、自然なスキルアップに繋がる。 | **3. "Garbage In, Garbage Out"の原則**<br>元のCOBOLのロジックにバグや仕様の欠陥があった場合、AIはそれを忠実に新しいシステムに移植してしまう。AIはビジネスそのものを改善するわけではない。 |
| **4. 属人化の解消**<br>特定の担当者しか知らなかったCOBOLの「秘伝のタレ」を、AIとの対話を通じて誰もが理解できるTypeScriptのコードとテストに変換できる。 | **4. 全体像の把握の難しさ**<br>AIは個別のプログラムの解析は得意だが、システム全体の複雑な依存関係や、バッチ処理の連鎖といった「大きな絵」を一度に理解するのは難しい。人間によるアーキテクチャレベルの俯瞰が必須。 |

**【この章のメッセージ】**
Viveコーディングは、運用保守の仕事を「何が起こるか分からない恐怖に怯える」コストセンターから、「システムの内部を誰よりも深く理解し、ビジネス価値を高める改善を仕掛ける」プロフィットセンターへと進化させます。あなたはもはやシステムの"お守り"ではなく、**価値を育てる"主治医"**なのです。

---

### 第3章：システム基盤の運用保守の方へ 〜「手順書」から「実行可能なコード」へ〜

サーバー構築、ネットワーク設定、障害からの復旧…。これらの手作業によるオペレーションは、ヒューマンエラーと常に隣り合わせであり、再現性の確保が大きな課題でした。

Viveコーディングの思想は、その「人の手」に依存した運用を、**Infrastructure as Code (IaC)** によって、信頼性と再現性の高いソフトウェア開発プロセスへと進化させます。ここでは、作業者の頭の中やExcelの手順書に眠る「暗黙知」を、いかにして実行可能な「コード」へと変換していくか、その具体的なステップを示します。

1.  **Step 1: 暗黙知を形式知へ - AIによる「コード化」**
    すべての始まりは、既存の資産をAIに「翻訳」させることからです。対象は、古くなったシェルスクリプト、Excelで管理された手順書、あるいは担当者へのヒアリング内容を書き起こしたメモでも構いません。

    これをAIにインプットとして与え、次のように依頼します。

    ```text
    # プロンプト例
    以下の作業手順書を読み込み、TerraformのHCLコードに変換してください。
    ネットワーク設定やインスタンスタイプは変数として定義し、
    各ステップがコードのどの部分に該当するかが分かるようにコメントを付与してください。

    [ここに手順書の内容を貼り付け]
    ```

    AIは、この自然言語や断片的なコードから、構造化されたIaCコードの**最初のドラフト**を生成します。これは、職人技を「誰もが読める設計図」に変換する、革命的な第一歩です。

2.  **Step 2: 安全な環境での「テスト」と「対話による洗練」**
    AIが生成したコードは、あくまでドラフトです。これを本番環境でいきなり実行するのは危険です。ここでTDDの考え方が活きてきます。

    まず、サンドボックスなどの安全な検証環境で `terraform plan` を実行し、AIが生成したコードがどのような変更を加えようとしているかを確認します。意図しない変更があれば、その差分（diff）をAIにフィードバックし、対話形式で修正を依頼します。

    ```text
    # プロンプト例
    `terraform plan` の結果、DBインスタンスのパラメータが意図せず変更されようとしています。
    このパラメータは既存の `[パラメータ名]` の値を維持するように修正してください。
    ```

    この**「計画(plan) -> 指摘 -> 修正」**のサイクルを繰り返すことで、コードの精度は飛躍的に向上します。これは、インフラ構成そのものをテストし、品質を保証するプロセスです。

3.  **Step 3: 「宣言」のバージョン管理と自動化**
    検証が完了したIaCコードは、Gitなどのバージョン管理システムにコミットします。これにより、インフラの構成変更はすべて記録され、「いつ、誰が、何を、なぜ変更したか」が追跡可能になります。

    最終的には、このリポジトリをCI/CDパイプライン（GitHub Actionsなど）に接続します。これにより、コードの変更が自動的にテストされ、承認されればインフラに適用される、という一連のプロセスが完成します。手作業によるデプロイ作業は、もはや不要です。

**【この章のメッセージ】**
ViveコーディングによるIaC化は、インフラ運用を「職人技」から「科学的なソフトウェア開発」へと昇華させます。あなたはもはや、手順書をなぞるオペレーターではありません。**コードでインフラを宣言し、テストと自動化によってその品質と信頼性を保証する、インフラのアーキテクト**へと進化するのです。

---

### 結論：あなたの役割は、どう進化するか？

Viveコーディングとは、単なる技術論ではありません。それは、私たちの働き方、価値の生み出し方そのものを、**AIという仲間と共に再定義するムーブメント**です。

コーディング、テスト、インフラ構築といった「作業」をAIに任せることで、人間である私たちは、
「**どの課題を解決すべきか？**」
「**どの技術を選択すべきか？**」
「**この品質で価値を提供できるか？**」
といった、より高度な<strong>「問い」と「意思決定」</strong>に時間を使うことができるようになります。

**そして何より、AIとの協業は、私たちエンジニアの「姿勢」そのものを変革します。失敗を恐れて石橋を叩いて渡る受動的な姿勢から、安全なテストという保険をかけた上で「まず試す」ことを楽しむ、能動的な実験者へと進化するのです。**

さあ、あなたも一緒に、"守る"開発から"育てる"開発へ。その第一歩を踏み出してみませんか。